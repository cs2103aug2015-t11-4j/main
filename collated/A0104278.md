# A0104278
###### src\main\java\gui\MainApp.java
``` java
     * 
     * @param itemList list of tasks from storage
     * @return list of tasks
     */
    private ObservableList<Text> createEventList(ArrayList<ItemForUserScreen> itemList) {
		event.clear();
    	for (int i = 0; i < itemList.size(); i++) {
			if (itemList.get(i).getTaskType().equals(TYPE_EVENT)){
				/**
```
###### src\main\java\gui\MainApp.java
``` java
			     */
			}
		}
    	return event;
    }
    
    private ObservableList<Text> createDeadlineList(ArrayList<ItemForUserScreen> itemList) {
    	deadline.clear();
    	for (int i = 0; i < itemList.size(); i++) {
			if (itemList.get(i).getTaskType().equals(TYPE_DEADLINE)){
				/**
```
###### src\main\java\gui\MainApp.java
``` java
			     */
			}
		}
    	return deadline;
    }
    
    private ObservableList<Text> createFloatingList(ArrayList<ItemForUserScreen> itemList) {
    	floating.clear();
    	for (int i = 0; i < itemList.size(); i++) {
			if (itemList.get(i).getTaskType().equals(TYPE_FLOATING)){
				/**
```
###### src\main\java\gui\MainApp.java
``` java
			     */
			}
		}
    	return floating;
    }
    
    private ObservableList<Text> createIncompleteList(ArrayList<ItemForUserScreen> itemList) {
    	incomplete.clear();
    	for (int i = 0; i < itemList.size(); i++) {
    		if (!(itemList.get(i).getIfComplete())) {
    			/**
```
###### src\main\java\gui\MainApp.java
``` java
			     */
			}
		}
    	return incomplete;
    }
    
    private ObservableList<Text> createCompleteList(ArrayList<ItemForUserScreen> itemList) {
    	complete.clear();
    	for (int i = 0; i < itemList.size(); i++) {
			if (itemList.get(i).getIfComplete()) {
				/**
```
###### src\main\java\gui\MainApp.java
``` java
			     */
			}
		}
    	return complete;
    }    
    
```
###### src\main\java\logic\Add.java
``` java
 */

package main.java.logic;

import java.util.logging.Level;
import java.util.logging.Logger;

import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;

/*
 * This class is for adding task
 * By creating the command with task input
 * Pass to storage for add respective task object
 */

public class Add implements Command {
	private static final Logger log = Logger.getLogger(Add.class.getName());
	private static final String KEYWORD_ADD = "Add";
	private static final String KEYWORD_UNDO = "Undo";
	private static final String KEYWORD_REDO = "Redo";
	private Task task;
	private Storage storage;
	private History history = History.getInstance();

	public Add(Task task, Storage storage) {
		this.task = task;
		this.storage = storage;

	}

	/*
	 * To add the task inside the storage
	 * 
	 */
	@Override
	public OutputToUI execute() {
		log.log(Level.INFO, "start to execute add");
		int code;
		OutputToUI outputToUI = new OutputToUI();
		if (!task.getIsDateTimeValid()) {
			log.log(Level.WARNING, "task in not valid");
			outputToUI = Controller.refreshScreen();
			// DataDisplay.printOutputToUI(outputToUI);
			outputToUI.setFeedbackMsg(DataDisplay.feedback(KEYWORD_ADD, -1));
			DataDisplay.printOutputToUI(outputToUI);
			return outputToUI;
		} else if (task.getIsDateTimeValid()) {
			log.log(Level.INFO, "start add into storage");
			code = storage.addOneItem(task);
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(KEYWORD_ADD, code));
			history.pushCommandToUndoList(this);
			history.clearRedoList();
		}
		return outputToUI;
	}

	/*
	 * To undo this add action. To delete the task inside the storage.
	 * 
	 */

	@Override
	public OutputToUI undo() {
		log.log(Level.INFO, "start to undo add");
		int code;

		OutputToUI outputToUI = new OutputToUI();
		log.log(Level.INFO, "start delete into storage");
		code = storage.deleteOneItem(task);

		outputToUI = Controller.refreshScreen();

		outputToUI.setFeedbackMsg(DataDisplay.feedback(KEYWORD_UNDO, code));
		return outputToUI;
	}

	/*
	 * To redo this add action. To add the task back inside the storage.
	 * 
	 */

	@Override
	public OutputToUI redo() {
		log.log(Level.INFO, "start to redo add");
		int code;
		OutputToUI outputToUI = new OutputToUI();
		if (!task.getIsDateTimeValid()) {
			log.log(Level.WARNING, "task in not valid");
			outputToUI = Controller.refreshScreen();
			// DataDisplay.printOutputToUI(outputToUI);
			outputToUI.setFeedbackMsg(DataDisplay.feedback(KEYWORD_ADD, -1));
			DataDisplay.printOutputToUI(outputToUI);
			return outputToUI;
		} else if (task.getIsDateTimeValid()) {
			log.log(Level.INFO, "start add into storage");
			code = storage.addOneItem(task);
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(KEYWORD_ADD, code));
			history.pushCommandToUndoList(this);
			outputToUI.setFeedbackMsg(DataDisplay.feedback(KEYWORD_REDO, code));
		}
		return outputToUI;
	}

}
```
###### src\main\java\logic\Command.java
``` java
 */

package main.java.logic;

/*Command interface
 * For all command to implement, so it all can managed as a command with same method:
 * execute, undo and redo*/

import main.java.resources.OutputToUI;

public interface Command {
	OutputToUI outputToUI = new OutputToUI();

	OutputToUI execute();

	OutputToUI undo();

	OutputToUI redo();
}
```
###### src\main\java\logic\Complete.java
``` java
 */

package main.java.logic;

import java.util.logging.Level;
import java.util.logging.Logger;

import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;

/*
 * This class is for completing task
 * By creating the command with item number input
 * Pass to storage for update respective task object
 */

public class Complete implements Command {
	private static final Logger log = Logger.getLogger(Complete.class.getName());
	private static final String KEYWORD_COMPLETE = "Complete";
	private static final String KEYWORD_UNDO = "Undo";
	private static final String KEYWORD_REDO = "Redo";
	private History history = History.getInstance();
	private int itemNum;
	private OutputToUI outputToUI = new OutputToUI();
	private Storage storage = Storage.getInstance();
	private Task task;

	public Complete(int itemNum, Storage storage) {
		this.itemNum = itemNum;
		this.storage = storage;
		Task task = Search.obtainTaskByItemNum(itemNum, history.getScreenList());
		this.task = task;
	}

	/*
	 * To complete the task inside the storage
	 * 
	 */
	@Override
	public OutputToUI execute() {
		log.log(Level.INFO, "start to execute complete");
		int code;
		if (task.equals(new Task())) {
			log.log(Level.WARNING, "task in not valid");
			code = 10;
			String feedbackMsg = DataDisplay.feedback(String.valueOf(itemNum), code);
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		} else if (!task.equals(new Task())) {
			log.log(Level.INFO, "start complete in storage");
			code = storage.completeOneItem(task);
			String feedbackMsg = DataDisplay.feedback(KEYWORD_COMPLETE, code);
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(feedbackMsg);
			history.pushCommandToUndoList(this);
			// DataDisplay.printUndoCommandList();
			history.clearRedoList();
		}
		return outputToUI;
	}

	/*
	 * To undo this complete action. To incomplete the task inside the storage.
	 * 
	 */

	@Override
	public OutputToUI undo() {
		log.log(Level.INFO, "start to execute undo");
		int code;
		task.setCompleted(true);
		code = storage.incompleteOneItem(task);
		String feedbackMsg = DataDisplay.feedback(KEYWORD_UNDO, code);
		outputToUI = Controller.refreshScreen();
		outputToUI.setFeedbackMsg(feedbackMsg);
		return outputToUI;
	}

	/*
	 * To redo this add action. To complete the task back inside the storage.
	 * 
	 */
	@Override
	public OutputToUI redo() {
		log.log(Level.INFO, "start to execute redo");
		int code;
		if (task.equals(new Task())) {
			log.log(Level.WARNING, "task in not valid");
			code = 10;
			String feedbackMsg = DataDisplay.feedback(String.valueOf(itemNum), code);
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		} else if (!task.equals(new Task())) {
			log.log(Level.INFO, "start add into storage");
			task.setCompleted(false);
			code = storage.completeOneItem(task);
			String feedbackMsg = DataDisplay.feedback(KEYWORD_REDO, code);
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(feedbackMsg);
			history.pushCommandToUndoList(this);
		}
		return outputToUI;
	}

	// unused due to change of plan
	/*
	 * for (int i = 0; i < storage.getTaskList().size(); i++){ if
	 * (storage.getTaskList().get(i).equals(task)){
	 * storage.getTaskList().get(i).setCompleted(ifComplete); } }
	 */

}
```
###### src\main\java\logic\Controller.java
``` java
 */

package main.java.logic;

import java.io.IOException;
import java.util.ArrayList;

import main.java.parser.FlexiCommands;
import main.java.parser.Parser;
import main.java.resources.DataDisplay;
import main.java.resources.ItemForUserScreen;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;

public class Controller {

	
	private static History history = History.getInstance();

	/*
	 * //Screen list is the list of tasks appeared on screen private
	 * ArrayList<Task> screenList;
	 * 
	 * //constructor for controller to pass around a screenList; public
	 * Controller(ArrayList<Task> screenList){ this.screenList = screenList; }
	 */

	static Storage storage = Storage.getInstance();

	// UI used for create command to be executed
	public static Command createCommand(String inputFromUser) {
		ArrayList<String> inputForAction = Parser.retrieveCommand(inputFromUser);
		Task task = null;
		
		//@SuppressWarnings("unused")
        Command command;
		
		Storage storage = Storage.getInstance();
		int itemNum;
		String contentForUpdate;
		ArrayList<String> inputForUpdate; //include itemNuN + contenteForUpdate
		switch (FlexiCommands.flexiCommands(inputForAction.get(0).toLowerCase())) {
		case "add":
			task = Parser.createTaskForAdd(inputForAction);
			command = new Add(task, storage);
			break;
		case "recurring":
			//ArrayList<Task> recurList = Parser.createRecurringTasks(inputForAction);
			command = new Recur(inputForAction);
			break;
		case "update":
			try{
				itemNum = Integer.parseInt(inputForAction.get(1));
			}catch (NumberFormatException e) {
				itemNum = 0;
			}
			command = new Update(itemNum, storage);
			break;
		case "-n":
			inputForUpdate = Parser.retrieveInputForUpdate(inputForAction.get(1));
			itemNum = Integer.parseInt(inputForUpdate.get(0));
			//System.out.printf(inputForUpdate.get(0)+"**"+ inputForUpdate.get(1));
			contentForUpdate = inputForUpdate.get(1);
			command = new UpdateName(itemNum, contentForUpdate);
			break;
		case "-st":
			inputForUpdate = Parser.retrieveInputForUpdate(inputForAction.get(1));
			itemNum = Integer.parseInt(inputForUpdate.get(0));
			contentForUpdate = inputForUpdate.get(1);
			command = new UpdateStartTime(itemNum, contentForUpdate);
			break;
			case "-sd":
			inputForUpdate = Parser.retrieveInputForUpdate(inputForAction.get(1));
			itemNum = Integer.parseInt(inputForUpdate.get(0));
			contentForUpdate = inputForUpdate.get(1);
			command = new UpdateStartDate(itemNum, contentForUpdate);
			break;
		case "-et":
			inputForUpdate = Parser.retrieveInputForUpdate(inputForAction.get(1));
			itemNum = Integer.parseInt(inputForUpdate.get(0));
			contentForUpdate = inputForUpdate.get(1);
			command = new UpdateEndTime(itemNum, contentForUpdate);
			break;
		case "-ed":
			inputForUpdate = Parser.retrieveInputForUpdate(inputForAction.get(1));
			itemNum = Integer.parseInt(inputForUpdate.get(0));
			contentForUpdate = inputForUpdate.get(1);
			command = new UpdateEndDate(itemNum, contentForUpdate);
			break;
		case "delete":
			String content[] = inputForAction.get(1).split(" ", 2);
			try{
                itemNum = Integer.parseInt(content[0]);
                String deletePara = "";
                if (content.length == 2){
                    if (content[1].equals("all")){ 
                        deletePara = FlexiCommands.flexiDisplayCommands(content[1]);
                        command = new Delete(itemNum, deletePara, storage);
                    }else {
                        command = new InvalidInput(content[1]);
                    }
                }else {
                    command = new Delete(itemNum, deletePara, storage);
                }
			} catch (NumberFormatException e){
                command = new InvalidInput(content[0]);
			}
			break;
		case "exit":
			command = new Exit();
			break;
		case "complete":
			try{
				System.out.println("Inside controller complete");
                itemNum = Integer.parseInt(inputForAction.get(1));     
                command = new Complete(itemNum, storage);
			} catch (NumberFormatException e){
                command = new InvalidInput(inputForAction.get(1));
			}
			break;
		case "incomplete":
			//System.out.println("**********INSIDE INCOMPLETE*********");
			try{
                itemNum = Integer.parseInt(inputForAction.get(1));     
                command = new Incomplete(itemNum, storage);
			} catch (NumberFormatException e){
                command = new InvalidInput(inputForAction.get(1));
			}
			break;
		case "set":
			command = new SetPath(inputForAction.get(1));
			break;
		case "undo":
			command = new Undo();
			break;
		case "redo":
			command = new Redo();
			break;
		case "display":
			command = new Display(inputForAction, storage);
			break;
		case "search" :
			command = new SearchKeyword(inputForAction, storage);
			break;
		case "help":
			command = new Help();
			break;
		case "invalid command":
		default:
			return command = new InvalidInput(inputForAction.get(0));
		}
		return command;
	}



	public static ArrayList<ItemForUserScreen> getItemList() {
		ArrayList<String> printOnScreenMsgList = new ArrayList<String>();

		ArrayList<Task> taskList = storage.getTaskList();
		ArrayList<ItemForUserScreen> itemList = new ArrayList<ItemForUserScreen>();
		printOnScreenMsgList = DataDisplay.displayList(taskList);
		for (int i = 0; i < taskList.size(); i++) {
			itemList.add(new ItemForUserScreen(taskList.get(i).getIsCompleted(), taskList.get(i).getTaskType(),
					printOnScreenMsgList.get(i)));
		}
		return itemList;
	}

	public static OutputToUI initializeProgram() throws IOException {
		storage.regenerateTaskList(); //TODO, Involve this when storage is correct
		
		ArrayList<Task> taskList = Search.obtainTodaySummary(storage);
		history.setScreenList(taskList);
		OutputToUI outputToUI = new OutputToUI();
		ArrayList<ItemForUserScreen> itemList = new ArrayList<ItemForUserScreen>();
		ArrayList<String> printOnScreenMsgList = DataDisplay.displayList(taskList);
		String typeOfScreen = "today";
		history.setCurrentScreen(typeOfScreen);
		String feedbackMsg = DataDisplay.feedback("init", 0);
		if (taskList.size() != 0) {
			for (int i = 0; i < taskList.size(); i++) {
				itemList.add(new ItemForUserScreen(taskList.get(i).getIsCompleted(), taskList.get(i).getTaskType(),
						printOnScreenMsgList.get(i)));
			}
		}
		outputToUI.setFeedbackMsg(feedbackMsg);
		outputToUI.setItemList(itemList);
		outputToUI.setTypeOfScreen(typeOfScreen);
		return outputToUI;
	}
	
	public static OutputToUI refreshScreen() {
		OutputToUI outputToUI;
		String typeOfScreen = history.getCurrentScreen();
		//String typeOfScreen = "all";
		ArrayList<String> displayInput = new ArrayList<String>();
		displayInput.add("display");
		displayInput.add(typeOfScreen);
		Command displayCmd = new Display(displayInput, storage);
		outputToUI = displayCmd.execute();
		return outputToUI;
	}
}

//@author : Jiahuan
//unused

//Unused after implementing command pattern

/*package main.java.logic;
import java.util.ArrayList;

import main.java.parser.Parser;
import main.java.resources.DataDisplay;
import main.java.resources.Task;
import main.java.storage.Storage;
import main.java.ui.UI;
//invoker class
public class LogicInvoker {
  

  //Switch case to decide which action to carry forward after first parsing
  //public static void takeAction(ArrayList<String> inputForSecondParsing, ArrayList<String> contentList) {
  public static void takeAction(String inputFromUser) {
      ArrayList<String> inputForAction = Parser.retrieveCommand(inputFromUser);
      int code = -1;
          switch (inputForAction.get(0).toLowerCase()){
          //if add, need to create task object for storage
          case "add":
              code = addInLogic(inputForAction);
              break;
          case "update":
              code = updateInLogic(inputForAction);
              break;
          case "delete":
              code = deleteInLogic(inputForAction);
              break;
          case "display":
              DataDisplay.displaySummary();
              break;
          default:
              UI.feedbackWrongCommand();
          }
      UI.feedback(inputForAction.get(0),code);  //not used for now (Yu Ju)
  }
  private static int deleteInLogic(ArrayList<String> inputForSecondParsing) {
      int code;
      int itemNum;
      itemNum = Integer.parseInt(inputForSecondParsing.get(1));
      code = Storage.deleteOneItem(itemNum);//pass in item number
      //System.out.println("deleted: " + code);  //prints out 0 (yj)
      return code;
  }
  private static int updateInLogic(ArrayList<String> inputForSecondParsing) {
      int code;
      Task task;
      int itemNum;
      String taskType;
      itemNum = Integer.parseInt(inputForSecondParsing.get(1)); 
      taskType = Storage.getTaskTypeByItemNum(itemNum); //get tasktype from logic
      inputForSecondParsing.add(taskType); //append tasktype to arraylist
      task = Parser.createTaskForUpdate(inputForSecondParsing); //create task obj 
      code = Storage.updateOneItem(itemNum, task); //pass in item number and task obj
      return code;
  }
  private static int addInLogic(ArrayList<String> inputForSecondParsing) {
      int code;
      Task task;
      task = Parser.createTaskForAdd(inputForSecondParsing);
      code = Storage.addOneItem(task);
      //System.out.println("added: " + code);  //prints out 0 (yj)
      return code;
  }

}
*/

/*//test
public static void main(String[] arg){
	Command command = createCommand("recur daily testing by 11/11 for 2 times");
	OutputToUI outputToUI = command.execute();
	System.out.println(outputToUI.getItemList());
}*/
// Testing
/*
 * public static final String TYPE_DEADLINE = "deadline"; public static
 * final String TYPE_EVENT = "event"; public static final String
 * TYPE_FLOATING = "floating"; public static void main(String arg[]) throws
 * IOException{ Storage storage = Storage.getInstance(); Task task1 = new
 * Task(TYPE_DEADLINE, "wake up", null, "01/01/2015", null, "0900", false);
 * Task task2 = new Task(TYPE_DEADLINE, "wash face with cool water", null,
 * "02/02/2015", null, "1100", true); Task task3 = new Task(TYPE_EVENT,
 * "go toilet", "01/01/2015", "01/02/2015", "0900", "1000", false); Task
 * task4 = new Task(TYPE_EVENT, "wash hand with soap", "03/02/2015",
 * "03/02/2015", "0915", "1100", true); Task task5 = new Task(TYPE_FLOATING,
 * "meet with bob", null, null, null, null, false); Task task6 = new
 * Task(TYPE_FLOATING, "eat breakfast", null, null, null, null, true);
 * Command command1 = new Add(task1, storage); Command command2 = new
 * Add(task2, storage); Command command3 = new Add(task3, storage); Command
 * command4 = new Add(task4, storage); Command command5 = new Add(task5,
 * storage); Command command6 = new Add(task6, storage); command1.execute();
 * command2.execute(); command3.execute(); command4.execute();
 * command5.execute(); command6.execute();
 * DataDisplay.displayList(storage.getTaskList());
 * ArrayList<ItemForUserScreen> itemList = new
 * ArrayList<ItemForUserScreen>(); itemList = getItemList(); for (int i =0;
 * i < itemList.size();i++){
 * System.out.println(itemList.get(i).getIfComplete()+"_"+itemList.get(i).
 * getTaskType()+"_"+itemList.get(i).getPrintOnScreenMsg()); } OutputToUI
 * outputToUI = initializeProgram();
 * DataDisplay.printOutputToUI(outputToUI); }
 */
// Above is testing block
```
###### src\main\java\logic\Delete.java
``` java
 */

package main.java.logic;

import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;

import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;

/*
 * This class is to delete task
 * By creating the command with item number and delete keyword input
 * Pass to storage to delete respective task object
 */

public class Delete implements Command {
	private static final Logger log = Logger.getLogger(Delete.class.getName());
	private static final String KEYWORD_DELETE = "Delete";
	private static final String KEYWORD_UNDO = "Undo";
	private static final String KEYWORD_REDO = "Redo";
	private static final String KEYWORD_DELETE_RECUR ="Delete recurring tasks";
	private History history = History.getInstance();
	private int itemNum;
	private Storage storage;
	private ArrayList<Task> screenList;
	private Task task;
	private ArrayList<Task> recurTaskList;
	private String deletePara;

	public Delete(int itemNum, String deletePara, Storage storage) {
		// this.task = task;
		this.itemNum = itemNum;
		this.storage = storage;
		this.deletePara = deletePara;
		this.screenList = history.getScreenList();

		Task task = Search.obtainTaskByItemNum(itemNum, screenList);
		this.task = task;
		if (deletePara.equals("all")) {
			recurTaskList = Search.obtainRecurTaskListByItemNum(itemNum, screenList);
		} else {
			recurTaskList = new ArrayList<Task>();
		}
	}


	/*
	 * To delete the task inside the storage
	 * 
	 */
	@Override
	public OutputToUI execute() {
		log.log(Level.INFO, "start to execute delete");
		int code;
		OutputToUI outputToUI = new OutputToUI();

		if (task.equals(new Task())) {
			log.log(Level.WARNING, "task in not valid");
			code = 10;
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum), code));
			return outputToUI;
		} else if (recurTaskList.isEmpty() && deletePara.equals("all")) {
			log.log(Level.WARNING, "task in not valid");
			code = 11;
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum), code));
			return outputToUI;
		} else if (!recurTaskList.isEmpty()) {
			log.log(Level.INFO, "start delete recur in storage");
			code = -1;

			int size = recurTaskList.size();
			for (int i = 0; i < size; i++) {
				Task recurTask = recurTaskList.get(i);
				code = storage.deleteOneItem(recurTask);
			}
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(KEYWORD_DELETE_RECUR, code));
			history.pushCommandToUndoList(this);
			history.clearRedoList();
			System.out.println("Inside delete recur");
			DataDisplay.printUndoCommandList();
			DataDisplay.printRedoCommandList();
			return outputToUI;
		} else {
			log.log(Level.INFO, "start delete in storage");
			code = storage.deleteOneItem(task);
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(KEYWORD_DELETE, code));
			history.pushCommandToUndoList(this);
			history.clearRedoList();
			System.out.println("Inside delete ");
			DataDisplay.printUndoCommandList();
			DataDisplay.printRedoCommandList();
		}
		return outputToUI;

	}

	/*
	 * To undo this delete action. To add the task inside the storage.
	 * 
	 */

	@Override
	public OutputToUI undo() {
		log.log(Level.INFO, "start to execute delete.undo");
		int code;
		OutputToUI outputToUI = new OutputToUI();
		if (!recurTaskList.isEmpty()) {
			log.log(Level.INFO, "start add recur in storage");
			code = -1;
			try {
				history.setRecurID();
			} catch (IOException e) {
				log.log(Level.WARNING, "Invalid recur ID");
			}
			int recurID = history.getNextRecurID();
			int size = recurTaskList.size();
			for (int i = 0; i < size; i++) {
				recurTaskList.get(i).setRecurringID(recurID);
				Task recurTask = recurTaskList.get(i);
				code = storage.addOneItem(recurTask);
			}
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(KEYWORD_UNDO, code));
			System.out.println("Inside delete undo recur");
			DataDisplay.printUndoCommandList();
			DataDisplay.printRedoCommandList();
			return outputToUI;
		}
		log.log(Level.INFO, "start add in storage");
		code = storage.addOneItem(task);
		outputToUI = Controller.refreshScreen();
		outputToUI.setFeedbackMsg(DataDisplay.feedback(KEYWORD_UNDO, code));
		System.out.println("Inside delete undo ");
		DataDisplay.printUndoCommandList();
		DataDisplay.printRedoCommandList();
		return outputToUI;
	}

	/*
	 * To redo this delete action. To delete the task back inside the storage.
	 * 
	 */

	@Override
	public OutputToUI redo() {
		log.log(Level.INFO, "start to execute add.redo");
		int code;
		OutputToUI outputToUI = new OutputToUI();
		if (task.equals(new Task())) {
			code = 10;
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum), code));
			return outputToUI;
		} else if (recurTaskList.isEmpty() && deletePara.equals("all")) {
			code = 11;
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum), code));
			return outputToUI;
		} else if (!recurTaskList.isEmpty()) {
			log.log(Level.INFO, "start delete recur in storage");
			code = -1;

			int size = recurTaskList.size();
			for (int i = 0; i < size; i++) {
				Task recurTask = recurTaskList.get(i);
				code = storage.deleteOneItem(recurTask);
			}
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(KEYWORD_REDO, code));
			history.pushCommandToUndoList(this);
			System.out.println("Inside delete redo recur");
			DataDisplay.printUndoCommandList();
			DataDisplay.printRedoCommandList();
			return outputToUI;
		}
		log.log(Level.INFO, "start delete in storage");
		code = storage.deleteOneItem(task);
		outputToUI = Controller.refreshScreen();
		outputToUI.setFeedbackMsg(DataDisplay.feedback(KEYWORD_REDO, code));
		history.pushCommandToUndoList(this);
		System.out.println("Inside delete redo");
		DataDisplay.printUndoCommandList();
		DataDisplay.printRedoCommandList();
		return outputToUI;
	}
```
###### src\main\java\logic\Display.java
``` java
 */

package main.java.logic;

import java.util.ArrayList;

import main.java.parser.FlexiCommands;
import main.java.resources.DataDisplay;
import main.java.resources.ItemForUserScreen;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;

/*
 * This class is to display task
 * By creating the command with user input
 * Pass to UI for display respective task objects
 */

public class Display implements Command {
	private ArrayList<String> inputForAction = new ArrayList<String>();
	private Storage storage;
	private History history = History.getInstance();

	public Display(ArrayList<String> userInput, Storage storage) {
		this.inputForAction = userInput;
		this.storage = storage;
	}

	@Override
	public OutputToUI execute() {
		OutputToUI outputToUI = new OutputToUI();
		ArrayList<String> printOnScreenMsgList = new ArrayList<String>();
		ArrayList<Task> taskList = new ArrayList<Task>();
		ArrayList<ItemForUserScreen> itemList = new ArrayList<ItemForUserScreen>();
		String feedbackMsg;
		String typeOfScreen = null;
		switch (FlexiCommands.flexiDisplayCommands(inputForAction.get(1).toLowerCase())) {
		case "today":
			taskList = Search.obtainTodaySummary(storage);
			typeOfScreen = "today";
			break;
		case "tomorrow":
			taskList = Search.obtainTomorrowSummary(storage);
			typeOfScreen = "tomorrow";
			break;
		case "floating":
			taskList = Search.obtainFloatingTasks(storage);
			typeOfScreen = "floating";
			break;
		case "event":
			taskList = Search.obtainEventTasks(storage);
			typeOfScreen = "event";
			break;
		case "deadline":
			taskList = Search.obtainDeadlineTasks(storage);
			typeOfScreen = "deadline";
			break;
		case "complete":
			taskList = Search.obtainAllCompleteTasks(storage);
			typeOfScreen = "complete";
			break;
		case "incomplete":
			taskList = Search.obtainAllIncompleteTasks(storage);
			typeOfScreen = "incomplete";
			break;
		case "search":
		case "all":
			taskList = Search.obtainAllTasks(storage);
			typeOfScreen = "all";
			break;
		case "help":
			typeOfScreen = "help";
			break;
		case "invalid display":
		default:
			typeOfScreen = "null";
			break;
		}
		
		printOnScreenMsgList = DataDisplay.displayList(taskList);
		history.setScreenList(taskList);
		history.setCurrentScreen(typeOfScreen);
		if (!taskList.isEmpty()){
			for (int i = 0; i < taskList.size(); i++) {
				itemList.add(new ItemForUserScreen(taskList.get(i).getIsCompleted(), 
						taskList.get(i).getTaskType(), printOnScreenMsgList.get(i)));
			}
		}
		if (typeOfScreen == "null"){
			feedbackMsg = DataDisplay.feedback("Display", -1);
		} else if(typeOfScreen == "help"){
			feedbackMsg = "Help is displayed";
		} else {
			feedbackMsg = DataDisplay.feedback("Display", 0);
		}
		outputToUI.setFeedbackMsg(feedbackMsg);
		outputToUI.setItemList(itemList);
		outputToUI.setTypeOfScreen(typeOfScreen);
		return outputToUI;
	}

	@Override
	public OutputToUI undo() {
		return null;
	}

	@Override
	public OutputToUI redo() {
		return null;
	}

	/* -unused
	outputToUI = history.gerSearchCommand().execute();
	itemList = outputToUI.getItemList();
	typeOfScreen = outputToUI.getTypeOfScreen();
	
	break;
*/
}
```
###### src\main\java\logic\Exit.java
``` java
 */

package main.java.logic;

import main.java.resources.OutputToUI;

/*
 * This class is for quit alt4
 * By creating the command with user input
 * Pass to storage to quit alt4
 */

public class Exit implements Command {

	@Override
	public OutputToUI execute() {
		OutputToUI outputToUI = new OutputToUI();
		outputToUI.setTypeOfScreen("exit");
		return outputToUI;
	}

	@Override
	public OutputToUI undo() {
		return null;
	}

	@Override
	public OutputToUI redo() {
		return null;
	}

}
```
###### src\main\java\logic\Help.java
``` java
 */

package main.java.logic;

import main.java.resources.OutputToUI;
/*
 * This class is for display help
 * By creating the command with user input
 * Pass to storage for display help
 */
public class Help implements Command{
	public Help(){
		
	}
	
	
	@Override
	public OutputToUI execute() {
		OutputToUI outputToUI = Controller.refreshScreen();
		outputToUI.setFeedbackMsg("Help is displayed");
		outputToUI.setTypeOfScreen("help");
		return outputToUI;
	}

	@Override
	public OutputToUI undo() {
		return null;
	}

	@Override
	public OutputToUI redo() {
		return null;
	}
	
}
```
###### src\main\java\logic\History.java
``` java
 */

package main.java.logic;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Stack;

import main.java.resources.Task;

/*
 * This class is for storing most of the history
 * Called only by logic
 */

public class History {
	private ArrayList<Task> screenList;
	private String currentScreen;
	private Stack<Command> undoCommandList;
	private Stack<Command> redoCommandList;
	private int nextRecurID = 1;
	private Command searchCommand;
	
	//private constructor
	private History(){
	screenList = new ArrayList<Task>();
	redoCommandList = new Stack<Command>();
	undoCommandList = new Stack<Command>();
	
	
	}

	//create history object
	private static History history = new History();
	
    //access to object, create one if there is none
    public static History getInstance(){
        if (history == null){
            history = new History();
        }
        return history;
    }
    
    //accessor
    public ArrayList<Task> getScreenList(){
    	return screenList;
    }
    
    public String getCurrentScreen(){
    	return currentScreen;
    }
    
    public Stack<Command> getUndoCommandList(){
    	return undoCommandList;
    }
    
    public Stack<Command> getRedoCommandList(){
    	return redoCommandList;
    }
    
    public Command popCommandToRedoList(){
    	Command command = redoCommandList.pop();
    	return command;
    }
    
    public Command popCommandToUndoList(){
    	Command command = undoCommandList.pop();
    	return command;
    }
    
    public int getNextRecurID(){
    	return nextRecurID;
    }
    
    public Command gerSearchCommand(){
    	return searchCommand;
    }
    
  //mutator 
    public void setScreenList(ArrayList<Task> screenList){
    	this.screenList = screenList;
    }
    
    public void setCurrentScreen(String currentScreen){
    	this.currentScreen = currentScreen;
    }
    
    public void pushCommandToUndoList(Command command){
    	undoCommandList.push(command);
    }

    
    public void pushCommandToRedoList(Command command){
    	redoCommandList.push(command);
    }

	public void clearRedoList() {
		redoCommandList.clear();
		
	}
	
    public void setRecurID() throws IOException{
    	nextRecurID = Search.obtainLargestRecurID()+1;
    }
    
    public void updateRecurID(){
    	nextRecurID++;
    }
    
    public void setSearchCommand(Command command){
    	searchCommand = command;
    }

}
```
###### src\main\java\logic\Incomplete.java
``` java
 */

package main.java.logic;

import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;
/*
 * This class is for incomplete task
 * By creating the command with item Number
 * Pass to storage for update respective task object
 */
public class Incomplete implements Command{

	private History history = History.getInstance();
	private OutputToUI outputToUI = new OutputToUI();
	private Storage storage = Storage.getInstance();
	private Task task;
	private int itemNum;
	
	public Incomplete(int itemNum, Storage storage){
		this.itemNum = itemNum;
		this.storage = storage;
		Task task = Search.obtainTaskByItemNum(itemNum, history.getScreenList());
		this.task = task;
		
	}
	
	@Override
	public OutputToUI execute() {
		int code;
		
		code = storage.incompleteOneItem(task);
		if (task.equals(new Task())){
			code = 10; 
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum),code));
			return outputToUI;
		}
		String feedbackMsg = DataDisplay.feedback("Incomplete", code);
		outputToUI = Controller.refreshScreen();
		outputToUI.setFeedbackMsg(feedbackMsg);
		history.pushCommandToUndoList(this);
		history.clearRedoList();
		return outputToUI;
	}

	@Override
	public OutputToUI undo() {
		int code;
		code = storage.completeOneItem(task);
		String feedbackMsg = DataDisplay.feedback("Undo", code);
		outputToUI = Controller.refreshScreen();
		outputToUI.setFeedbackMsg(feedbackMsg);
		return outputToUI;
	}

	@Override
	public OutputToUI redo() {
		int code;
		
		code = storage.incompleteOneItem(task);
		if (task.equals(new Task())){
			code = 10; 
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum),code));
			return outputToUI;
		}
		String feedbackMsg = DataDisplay.feedback("Redo", code);
		outputToUI = Controller.refreshScreen();
		outputToUI.setFeedbackMsg(feedbackMsg);
		history.pushCommandToUndoList(this);
		return outputToUI;
	}
	
	//private boolean ifComplete = false;
	//private int itemNum;
	//un-used
	//System.out.println("***");
	//DataDisplay.displayList(history.getScreenList());
	//System.out.println("***");
	
	//un-used
	//System.out.println("***");
	//DataDisplay.displayList(history.getScreenList());
	//System.out.println("***");
}
```
###### src\main\java\logic\InvalidInput.java
``` java
 */

package main.java.logic;

import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;

/*
 * This class is for handle invalid inputs
 * By creating the command with user input
 * Pass to storage to acknowledge the invalid input
 */

public class InvalidInput implements Command{
	@SuppressWarnings("unused")
    private History history;
	
	private String invalidInput;
	
	
	public InvalidInput(String invalidInput){
		history = History.getInstance();
		this.invalidInput = invalidInput;
	}
	
	@Override
	public OutputToUI execute() {
		OutputToUI outputToUI = Controller.refreshScreen();
		
		outputToUI.setFeedbackMsg(DataDisplay.feedback(invalidInput,1));
		return outputToUI;
	}

	@Override
	public OutputToUI undo() {
		return null;
	}

	@Override
	public OutputToUI redo() {
		return null;
	}

}
```
###### src\main\java\logic\Recur.java
``` java
 */

package main.java.logic;

import java.io.IOException;
import java.util.ArrayList;

import main.java.parser.Parser;
import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;

public class Recur implements Command{
	private History history;
	private Storage storage;
	private ArrayList<Task> recurList;
	
	@SuppressWarnings("unused")
    private int recurID;
	
	public Recur(){}
	
	public Recur(ArrayList<String> inputForAction) {
		storage = Storage.getInstance();
		history = History.getInstance();
		try {
			history.setRecurID();
		} catch (IOException e) {
			e.printStackTrace();
		}
		recurID = history.getNextRecurID();
		this.recurList = Parser.createRecurringTasks(inputForAction);

	}
	
	public History getHistory(){
		return history;
	}
	
	//Mutator
	public void setHistory(History history){
		this.history = History.getInstance();
	}
	
	public void setStorage(Storage storage){
		this.storage = Storage.getInstance();
	}
	
	public void setRecurList(ArrayList<Task> recurList){
		this.recurList = recurList;
	}
	
	@Override
	public OutputToUI execute() {
		int code = 0;
		OutputToUI outputToUI = new OutputToUI();
		if (recurList.isEmpty()){
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback("Recurring",-1));
			return outputToUI;
		}
		
		for (int i = 0; i < recurList.size(); i++){
			Task task = recurList.get(i);
			code = storage.addOneItem(task); 
		}

		try {
			history.setRecurID();
		} catch (IOException e) {
			e.printStackTrace();
		}
		outputToUI = Controller.refreshScreen();
				
		outputToUI.setFeedbackMsg(DataDisplay.feedback("Recurring",code));
		history.pushCommandToUndoList(this);
		history.clearRedoList();
		return outputToUI;

	}

	@Override
	public OutputToUI undo() {
		int code = 0;
			
		OutputToUI outputToUI = new OutputToUI();
		
		for (int i = 0; i < recurList.size(); i++){
			Task task = recurList.get(i);
			code = storage.deleteOneItem(task); 
		}
		outputToUI = Controller.refreshScreen();
		
		outputToUI.setFeedbackMsg(DataDisplay.feedback("Undo", code));
		return outputToUI;

	}

	@Override
	public OutputToUI redo() {
		int code = 0;
		OutputToUI outputToUI = this.execute();
		outputToUI.setFeedbackMsg(DataDisplay.feedback("Redo", code));
		history.pushCommandToUndoList(this);
		return outputToUI;
	}
	
	//-unused
	//System.out.println("Inside recur constructor : ");
	//DataDisplay.displayList(recurList);

	//history.setRecurID();
	//System.out.println("recur ID in recur is = " + history.getNextRecurID());
	
	/*ArrayList<Task> tempList = storage.getTaskList();
	System.out.println("Inside recur Execute() : ");
	DataDisplay.displayList(tempList);*/
	
	/*ArrayList<Task> tempList = storage.getTaskList();
	System.out.println("Inside recur Execute(), after for loop for adding tasks : ");
	DataDisplay.displayList(tempList);*/
	//history.updateRecurID();
	
	/*tempList = storage.getTaskList();
	System.out.println("Inside recur Execute(), after for loop for adding tasks : ");
	DataDisplay.displayList(tempList);*/
	//System.out.println("After refreshScreen in recur.execute : ");
	//DataDisplay.printOutputToUI(outputToUI);
	
	//needs to handle if some task is added while others are not
	/*if (code != 0){
		
	}*/
}
```
###### src\main\java\logic\Redo.java
``` java
 */

package main.java.logic;

import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
/*
 * This class is for redo task
 * By creating the command with no input
 * Redo the command
 */
public class Redo implements Command{
	private History history = History.getInstance();
	
	public Redo(){}
	
	@Override
	public OutputToUI execute() {
		int code = 0;
		if (history.getRedoCommandList().isEmpty()){
			OutputToUI outputToUI = Controller.refreshScreen();
			String feedbackMsg = DataDisplay.feedback("Redo", 9);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		}
		Command command = history.popCommandToRedoList();
		OutputToUI outputToUI = command.redo();
		outputToUI.setFeedbackMsg(DataDisplay.feedback("Redo", code));
		
		return outputToUI;
	}

	@Override
	public OutputToUI undo() {
		return null;
	}

	@Override
	public OutputToUI redo() {
		return null;
	}

}
```
###### src\main\java\logic\Search.java
``` java
	public static int obtainLargestRecurID() throws IOException {
		Storage storage = Storage.getInstance();

		storage.regenerateTaskList();
		int temp, largestRecurID = 0;

		for (int i = 0; i < storage.getTaskList().size(); i++){
			if (storage.getTaskList().get(i).getRecurringID() > largestRecurID){
				temp = storage.getTaskList().get(i).getRecurringID();
				largestRecurID = temp;
			}
		}
		return largestRecurID;
	}
	
    /* 
```
###### src\main\java\logic\Search.java
``` java
	/*ArrayList<Task> tempList = storage.getTaskList();
	System.out.println("Inside search.largestRecurID(), before regenerateTaskList : ");
	DataDisplay.displayList(tempList);*/
	/*tempList = storage.getTaskList();
	System.out.println("Inside search.largestRecurID(), after regenerateTaskList : ");
	DataDisplay.displayList(tempList);*/
	//	System.out.println("Inside Search.obtainLargestrecurID() : " + storage.getTaskList().size());
	//		System.out.println("RecurID is" + storage.getTaskList().get(i).getRecurringID());
}
```
###### src\main\java\logic\searchRecurDemo.java
``` java
 */

package main.java.logic;

import java.io.IOException;

import main.java.storage.Storage;

/*
 * This class is for testing and demo the search recur function
 */

public class searchRecurDemo {
	public static void main (String[] arg) throws IOException{
		@SuppressWarnings("unused")
        History history = History.getInstance();
		
		@SuppressWarnings("unused")
        Storage storage = Storage.getInstance();
		
		System.out.println(obtainLargestRecurID());
	}
	
	public static int obtainLargestRecurID() throws IOException {
		Storage storage = Storage.getInstance();
		storage.regenerateTaskList();
		System.out.println("INSIDE: " + storage.getTaskList().size());
		int temp, largestRecurID = 0;
		for (int i = 0; i < storage.getTaskList().size(); i++){
			System.out.println(i);
			System.out.println(i + ": RecurID is" + storage.getTaskList().get(i).getRecurringID());
			if (storage.getTaskList().get(i).getRecurringID() > largestRecurID){
				
				temp = storage.getTaskList().get(i).getRecurringID();
				largestRecurID = temp;
			}
		}
		return largestRecurID;
	}
}
```
###### src\main\java\logic\SetPath.java
``` java
 */

package main.java.logic;

import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.storage.Storage;
/*
 * This class is for set new directory
 * By creating the command with task input of the new path
 * Pass to storage for update directory
 */
public class SetPath implements Command{
	private Storage storage = Storage.getInstance();
	//private History history = History.getInstance();
	private String newPath;
	
	public SetPath(String newPath){
		this.newPath = newPath;
	}
	
	@Override
	public OutputToUI execute() {
	    int code;
	    
		code = storage.changeDirectory(newPath);
		OutputToUI outputToUI = Controller.refreshScreen();
		String feedbackMsg = DataDisplay.feedback("Set new directory", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		return outputToUI;
	}

	@Override
	public OutputToUI undo() {
		return null;
	}

	@Override
	public OutputToUI redo() {
		return null;
	}

}
```
###### src\main\java\logic\Sort.java
``` java
 */

package main.java.logic;

import java.util.ArrayList;
import java.util.Collections;

import main.java.resources.Task;
import main.java.resources.TaskComparator;
import main.java.storage.Storage;

/*
 * This class is for sort the internal list
 * By creating the command with tasklist
 * sort in order of complete/incomplete, event+deadline/floating, time and date, task string alphabet
 */

public class Sort {

	public static final String TYPE_DEADLINE = "deadline";
	public static final String TYPE_EVENT = "event";
	public static final String TYPE_FLOATING = "floating";


	
	private static Storage storage = Storage.getInstance();
	private Task task;
	private Integer taskTime;
	private Integer taskDate;
	private String taskContent;

	// constructor
	public Sort(Task task, int taskDate, int taskTime, String taskContent) {
		this.task = task;
		this.taskDate = taskDate;
		this.taskTime = taskTime;
		this.taskContent = taskContent;
	}

	// accessor
	public Task getTask() {
		return task;
	}

	public Integer getTaskTime() {
		return taskTime;
	}

	public Integer getTaskDate() {
		return taskDate;
	}

	public String getTaskContent() {
		return taskContent;
	}

	// mutator
	public void setTask(Task task) {
		this.task = task;
	}

	public void setTaskTime(Integer taskTime) {
		this.taskTime = taskTime;
	}

	public void setTaskDate(Integer taskDate) {
		this.taskDate = taskDate;
	}

	public void setTaskContent(String taskContent) {
		this.taskContent = taskContent;
	}

	// sort all by ifcomplete, event/deadline or floating, time, taskcontent
	public static ArrayList<Task> sortAll() {

		ArrayList<Task> sortResult = new ArrayList<Task>();
		//return empty list if no task in storage
		if (storage.getTaskList().size()==0){
			return sortResult;
		}
		
		ArrayList<Task> incompleteList = new ArrayList<Task>();
		ArrayList<Task> completeList = new ArrayList<Task>();
		ArrayList<Task> incompleteFloatingList = new ArrayList<Task>();
		ArrayList<Task> completeFloatingList = new ArrayList<Task>();
		ArrayList<Task> incompleteNonFloatingList = new ArrayList<Task>();
		ArrayList<Task> completeNonFloatingList = new ArrayList<Task>();
		ArrayList<Task> incompleteNonFloatingListSorted = new ArrayList<Task>();
		ArrayList<Task> completeNonFloatingListSorted = new ArrayList<Task>();
		
		incompleteList = Search.obtainAllIncompleteTasks(storage);

		completeList = Search.obtainAllCompleteTasks(storage);

		incompleteFloatingList = getFloatingList(incompleteList);

		completeFloatingList = getFloatingList(completeList);

		incompleteNonFloatingList = getNonFloatingList(incompleteList);

		completeNonFloatingList = getNonFloatingList(completeList);

		ArrayList<Sort> sortListForIncomplete = createSortList(incompleteNonFloatingList);
		ArrayList<Sort> sortListForComplete = createSortList(completeNonFloatingList);
		
		Collections.sort(sortListForIncomplete, new TaskComparator());
		if (sortListForIncomplete.size()!=0){
			for (int i = 0; i < sortListForIncomplete.size(); i ++){
			incompleteNonFloatingListSorted.add(sortListForIncomplete.get(i).getTask());
			}
		}
		Collections.sort(sortListForComplete, new TaskComparator());
		if (sortListForComplete.size()!=0){
			for (int i = 0; i < sortListForComplete.size(); i ++){
			completeNonFloatingListSorted.add(sortListForComplete.get(i).getTask());
			}
		}
		
		if (completeNonFloatingList.size() != 0) {
			for (int i = 0; i < completeNonFloatingList.size(); i++) {
				sortResult.add(completeNonFloatingListSorted.get(i));
			}
		}

		if (completeFloatingList.size() != 0) {
			for (int i = 0; i < completeFloatingList.size(); i++) {
				sortResult.add(completeFloatingList.get(i));
			}
		}

		if (incompleteNonFloatingList.size() != 0) {
			for (int i = 0; i < incompleteNonFloatingList.size(); i++) {
				sortResult.add(incompleteNonFloatingListSorted.get(i));
			}
		}

		if (incompleteFloatingList.size() != 0) {
			for (int i = 0; i < incompleteFloatingList.size(); i++) {
				sortResult.add(incompleteFloatingList.get(i));
			}
		}

		return sortResult;
	}

	private static ArrayList<Sort> createSortList(ArrayList<Task> list) {

		ArrayList<Sort> sortList = new ArrayList<Sort>();
		if (list.size() != 0) {
			for (int i = 0; i < list.size(); i++) {
				Task task = list.get(i);
				sortList.add(new Sort(task, createTaskDate(task), createTaskTime(task), task.getTaskDescription()));
			}
		}
		return sortList;
	}

	// get the floatig out of the list of tasks
	private static ArrayList<Task> getFloatingList(ArrayList<Task> list) {
		ArrayList<Task> result = new ArrayList<Task>();
		for (int i = 0; i < list.size(); i++) {
			if (list.get(i).getTaskType().equals("floating")) {
				result.add(list.get(i));
			}
		}
		return result;
	}

	// get the non-floatig (event, deadline) out of the list of tasks
	private static ArrayList<Task> getNonFloatingList(ArrayList<Task> list) {
		ArrayList<Task> result = new ArrayList<Task>();
		for (int i = 0; i < list.size(); i++) {
			if (!list.get(i).getTaskType().equals("floating")) {
				result.add(list.get(i));
			}
		}
		return result;
	}

	private static int createTaskDate(Task task) {
		int taskDate = 0;
		if (task.getTaskType().equals("event")) {
			String[] date = task.getStartDate().split("/");
			int day = Integer.parseInt(date[0]);
			int month = Integer.parseInt(date[1]);
			int year = Integer.parseInt(date[2]);

			taskDate = day + month * 100 + year * 10000;
		}

		if (task.getTaskType().equals("deadline")) {
			String[] date = task.getEndDate().split("/");
			int day = Integer.parseInt(date[0]);
			int month = Integer.parseInt(date[1]);
			int year = Integer.parseInt(date[2]);

			taskDate = day + month * 100 + year * 10000;
		}
		return new Integer(taskDate);
	}

	private static int createTaskTime(Task task) {
		int taskTime = 0;
		if (task.getEndTime().equals("-")){
			return taskTime;
		} else if (task.getTaskType().equals("event")) {
			int hour = Integer.parseInt(task.getStartTime().substring(0, 2));
			int minute = Integer.parseInt(task.getStartTime().substring(2));
			taskTime = minute + hour * 100;

		} else if (task.getTaskType().equals("deadline")) {
			int hour = Integer.parseInt(task.getEndTime().substring(0, 2));
			int minute = Integer.parseInt(task.getEndTime().substring(2));
			taskTime = minute + hour * 100;
		}

		return new Integer(taskTime);
	}

	//@@ author a0104278-unused
	//originally for testing
/*		public static void main(String arg[]) {

	Task task1 = new Task(TYPE_DEADLINE, "wake up", "null", "01/01/2015", "null", "0900", false, false, 0);
	Task task2 = new Task(TYPE_DEADLINE, "wash face with cool water", "null", "02/02/2015", "null", "1100", true, false, 0);
	Task task3 = new Task(TYPE_EVENT, "go toilet", "01/01/2015", "01/02/2015", "0900", "1000", false, false, 0);
	Task task4 = new Task(TYPE_EVENT, "wash hand with soap", "03/02/2015", "03/02/2015", "0915", "1100", true, false, 0);
	Task task5 = new Task(TYPE_FLOATING, "meet with bob", "null", "null", "null", "null", false, false, 0);
	Task task6 = new Task(TYPE_FLOATING, "eat breakfast", "null", "null", "null", "null", true, false, 0);
	//Task task7 = new Task(TYPE_DEADLINE, "wake up", "null", "01/01/2015", "null", "0900", false, false);	
	//int taskTime = createTaskTime(task1);
	//int taskTime2 = createTaskTime(task4);
	//int taskDate = createTaskDate(task1);
	//int taskDate2 = createTaskDate(task3);
	p(taskTime);
	p(taskTime2);
	p(taskDate);
	p(taskDate2);
	
	
	Sort sort = new Sort(task1, createTaskDate(task1), createTaskTime(task1), task1.getTaskDescription());
	if(sort.getTask().equals(task1)){
		p(sort.getTaskDate());
		p(sort.getTaskTime());
		System.out.println(sort.getTaskContent());
	}
	
	ArrayList<Task> list = new ArrayList<Task>();
	ArrayList<Sort> sortList = new ArrayList <Sort>();
	
	list.add(task1);
	list.add(task2);
	list.add(task3);
	list.add(task4);
	list.add(task5);
	list.add(task6);
	sortList = createSortList(list);
	printSortList(sortList, list);
	
	Storage storage = Storage.getInstance();
	storage.addOneItem(task1);
	storage.addOneItem(task2);
	storage.addOneItem(task3);
	storage.addOneItem(task4);
	storage.addOneItem(task5);
	storage.addOneItem(task6);
	DataDisplay.displayList(storage.getTaskList());
	ArrayList<Task> sortResult = sortAll();
	DataDisplay.displayList(sortResult);
	
}

	// sort a task list by time then followed by alphabetic order of content
	/*
	 * public static ArrayList<Task> sortByTime(ArrayList<Task> listForSort) {
	 * ArrayList<Task> sortResult = new ArrayList<Task>(); ArrayList<Sort>
	 * sortList = createSortList(listForSort); Collections.sort(sortList, new
	 * TaskComparator()); for (int i = 0; i < sortList.size(); i++) {
	 * sortResult.add(sortList.get(i).getTask()); } return sortResult; }
	 * 
	 * // create sortlist with sort objects for sort private static
	 * ArrayList<Sort> createSortList(ArrayList<Task> listForSort) {
	 * ArrayList<Sort> sortList = new ArrayList<Sort>(); for (int i = 0; i <
	 * listForSort.size(); i++) { Task task = listForSort.get(i);
	 * sortList.add(new Sort(task, task.getTaskDescription(),
	 * task.getIsCompleted())); }
	 * 
	 * return sortList; }
	 */
	// create calendar from task timing 
	
	//System.out.println("***");
	//System.out.println("incompleteList:");
	//DataDisplay.displayList(incompleteList);
	//System.out.println("***");
	/*System.out.println("***");
	System.out.println("completeList:");
	DataDisplay.displayList(completeList);
	System.out.println("***");*/
	/*System.out.println("***");
	System.out.println("incompleteFloatingList:");
	DataDisplay.displayList(incompleteFloatingList);
	System.out.println("***");*/
	/*System.out.println("***");
	System.out.println("completeFloatingList:");
	DataDisplay.displayList(completeFloatingList);
	System.out.println("***");*/
	/*System.out.println("***");
	System.out.println("incompleteNonFloatingList:");
	DataDisplay.displayList(incompleteNonFloatingList);
	System.out.println("***");*/
	/*System.out.println("***");
	System.out.println("completeList:");
	DataDisplay.displayList(completeList);
	System.out.println("***");

			// int hour = Integer.parseInt(task.getStartTime().substring(0, 2));
			// int minute = Integer.parseInt(task.getStartTime().substring(2));

			//p(year);
			//p(month);
			//p(day);
			// p(hour);
			// p(minute);
			//System.out.println(taskDate)

			// int hour = Integer.parseInt(task.getEndTime().substring(0, 2));
			// int minute = Integer.parseInt(task.getEndTime().substring(2));

			//p(year);
			//p(month);
			//p(day);
			// p(hour);
			// p(minute);
			//System.out.println(taskDate);

			//p(hour);
			//p(minute);
			//System.out.println(taskTime);

			//p(hour);
			//p(minute);
			//System.out.println(taskTime)
			 * 
private static void printSortList(ArrayList<Sort> sortList, ArrayList<Task> list){
	Sort sort;
	for (int i = 0; i < sortList.size(); i++){
		sort = sortList.get(i);
		if(sort.getTask().equals(list.get(i))){
			p(sort.getTaskDate());
			p(sort.getTaskTime());
			System.out.println(sort.getTaskContent());
		}
	}
}

private static void p(int i){
	System.out.println(i);
}
*/
	

	/*
	private static void p(int toprint) {
		System.out.println(toprint);
	}
    */

	/*
	 * Sorts task by task type and description in the taskList
	 * 
```
###### src\main\java\logic\Undo.java
``` java
 */

package main.java.logic;

import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
/*
 * This class is for undo
 * By creating the command with no input
 */
public class Undo implements Command{
	
	private History history = History.getInstance();
	private Command command;
	
	public Undo(){
	}
	
	@Override
	public OutputToUI execute() {
		int code = 0;
		if (history.getUndoCommandList().isEmpty()){
			OutputToUI outputToUI = Controller.refreshScreen();
			String feedbackMsg = DataDisplay.feedback("Undo", 9);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		}
		command = history.popCommandToUndoList();
		OutputToUI outputToUI = command.undo();
		System.out.println("inside undo success");
		outputToUI.setFeedbackMsg(DataDisplay.feedback("Undo", code));
		history.pushCommandToRedoList(command);
		return outputToUI;
	}

	@Override
	public OutputToUI undo() {
		return null;
	}

	@Override
	public OutputToUI redo() {
		return null;
	}

}
```
###### src\main\java\logic\Update.java
``` java
 */

package main.java.logic;

import java.util.ArrayList;
import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;

/*
 * This class is for update
 * By creating the command with item number
 */

public class Update implements Command{
	private int itemNum;
	private Storage storage;
	private History history = History.getInstance();
	private ArrayList<Task> screenList;
	private Task task;
	
	public Update(int itemNum, Storage storage){
		this.itemNum=itemNum;
		this.storage = storage;
		screenList = history.getScreenList();
		Task task = new Task();
		if (itemNum !=0){
			task = Search.obtainTaskByItemNum(itemNum, screenList);
		}
		
		this.task = task;
	}
	
	@Override
	public OutputToUI execute() {
		OutputToUI outputToUI = new OutputToUI();
		int code;
		if (itemNum == 0){
			code = -1;
			String feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		}else if (task.equals(new Task())){
			code = 10; 
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum),code));
			return outputToUI;
		}
		storage.deleteOneItem(task);
		String inputBoxMsg = DataDisplay.displayTaskNeedForUpdate(task);
		String feedbackMsg = "Please edit the task to update"; 
		outputToUI = Controller.refreshScreen();
		outputToUI.setInputBoxMsg(inputBoxMsg);
		outputToUI.setFeedbackMsg(feedbackMsg);
		history.clearRedoList();
		return outputToUI;
	}

	@Override
	public OutputToUI undo() {
		Command command = history.popCommandToUndoList();
		command.undo();
		OutputToUI outputToUI = Controller.refreshScreen();
		int code = storage.addOneItem(task);
		outputToUI.setFeedbackMsg(DataDisplay.feedback("Undo", code));
		outputToUI = Controller.refreshScreen();
		return outputToUI;
	}

	@Override
	public OutputToUI redo() {
		return null;
	}

}

//@@Author: Jiahuan
//-unused
//unused as a new method of update is implemented

/*package main.java.logic;

import main.java.resources.Task;
import main.java.storage.Storage;
//Second step of update, user change its message and enter
public class UpdateWithTask implements Command{
  private Task task;
  
  public UpdateWithTask (Task task){
      this.task = task;
  }
  
  //recreate the task requested by user
  @Override
  public void execute() {
      Storage.addOneItem(task);
  }

}
*/
```
###### src\main\java\logic\UpdateEndDate.java
``` java
 */

package main.java.logic;

import java.util.ArrayList;

import main.java.parser.DateAndTime;
import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;

/*
 * This class is for update end date
 * By creating the command with item number and the expected new end date
 */

public class UpdateEndDate implements Command{
	private Storage storage = Storage.getInstance();
	private String newEndDate;
	private int itemNum;
	private Task oldTask;
	private Task newTask;
	private ArrayList<Task> screenList;
	private History history = History.getInstance();
	
	
	public UpdateEndDate(int itemNum, String newEndDate){
		this.newEndDate = newEndDate;
		this.itemNum = itemNum;
		screenList = history.getScreenList();
		this.oldTask = Search.obtainTaskByItemNum(itemNum, screenList);
		if (oldTask.getEndDate().equals("-")||DateAndTime.reformatDate(newEndDate).equals("invalid date format")){
			newTask = new Task();
		} else {
		newTask = new Task (oldTask.getTaskType(), oldTask.getTaskDescription(), oldTask.getStartDate(), oldTask.getEndDate(),
				oldTask.getStartTime(), oldTask.getEndTime(), oldTask.getIsCompleted(),
				oldTask.getIsDateTimeValid(), oldTask.getRecurringID());
		newTask.setEndDate(DateAndTime.reformatDate(newEndDate));
		}
	}
	
	@Override
	public OutputToUI execute() {
		int code;
		OutputToUI outputToUI = new OutputToUI();
		String feedbackMsg;
		if (oldTask.equals(new Task())){
			code = 10; 
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum),code));
			return outputToUI;
		}
		//If empty, return feedback msg saying task description cannot be empty
		if (newEndDate.isEmpty()){
			code = 5;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		} else if (newTask.equals(new Task())){
			code = 6;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		}
		System.out.printf(newEndDate);
		storage.deleteOneItem(oldTask);
		System.out.println("Ouside empty");
		storage.addOneItem(newTask);
		outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Update", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		history.pushCommandToUndoList(this);
		history.clearRedoList();
		return outputToUI;
	}

	@Override
	public OutputToUI undo() {
		int code;
		
		String feedbackMsg;
		storage.deleteOneItem(newTask);
		storage.addOneItem(oldTask);
		OutputToUI outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Update", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		return outputToUI;
	}

	@Override
	public OutputToUI redo() {
		int code;
		OutputToUI outputToUI = new OutputToUI();
		String feedbackMsg;
		if (oldTask.equals(new Task())){
			code = 10; 
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum),code));
			return outputToUI;
		}
		//If empty, return feedback msg saying task description cannot be empty
		if (newEndDate.isEmpty()){
			code = 5;
			feedbackMsg = DataDisplay.feedback("Redo", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		} else if (newTask.equals(new Task())){
			code = 6;
			feedbackMsg = DataDisplay.feedback("Redo", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		}
		System.out.printf(newEndDate);
		storage.deleteOneItem(oldTask);
		System.out.println("Ouside empty");
		storage.addOneItem(newTask);
		outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Redo", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		history.pushCommandToUndoList(this);
		return outputToUI;
	}

}
```
###### src\main\java\logic\UpdateEndTime.java
``` java
 */

package main.java.logic;

import java.util.ArrayList;

import main.java.parser.DateAndTime;
import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;
/*
 * This class is for update end time
 * By creating the command with item number and expected time
 */
public class UpdateEndTime implements Command{
	private Storage storage = Storage.getInstance();
	private String newEndTime;
	private int itemNum;
	private Task oldTask;
	private Task newTask;
	private ArrayList<Task> screenList;
	private History history = History.getInstance();
	private ArrayList<Task> oldRecurTaskGroup = new ArrayList<Task>();
	private ArrayList<Task> newRecurTaskGroup = new ArrayList<Task>();
	
	
	public UpdateEndTime(int itemNum, String newEndTime){
		this.newEndTime = newEndTime;
		this.itemNum = itemNum;
		screenList = history.getScreenList();
		this.oldTask = Search.obtainTaskByItemNum(itemNum, screenList);
		if (oldTask.getEndTime().equals("-")||DateAndTime.reformatTime(newEndTime).equals("invalid time format")||!DateAndTime.isValidUpdateET(oldTask, newEndTime)){
			newTask = new Task();
		} 
		else if(oldTask.getRecurringID() == 0) {
			newTask = new Task (oldTask.getTaskType(), oldTask.getTaskDescription(), oldTask.getStartDate(), oldTask.getEndDate(),
					oldTask.getStartTime(), oldTask.getEndTime(), oldTask.getIsCompleted(),
					oldTask.getIsDateTimeValid(), oldTask.getRecurringID());
			newTask.setEndTime(DateAndTime.reformatTime(newEndTime));

		}
```
###### src\main\java\logic\UpdateEndTime.java
``` java
	@Override
	public OutputToUI execute() {
		int code;
		OutputToUI outputToUI = new OutputToUI();
		String feedbackMsg;
		if (oldTask.equals(new Task())){
			code = 10; 
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum),code));
			return outputToUI;
		}
		//If empty, return feedback msg saying task description cannot be empty
		if (newEndTime.isEmpty()){
			code = 7;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		} else if (newTask.equals(new Task())){
			code = 8;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		}
		if(this.oldRecurTaskGroup.isEmpty()) {
			storage.deleteOneItem(oldTask);
			System.out.println("Ouside empty");
			storage.addOneItem(newTask);
		}
```
###### src\main\java\logic\UpdateEndTime.java
``` java
		outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Update", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		history.pushCommandToUndoList(this);
		history.clearRedoList();
		return outputToUI;
	}

	@Override
	public OutputToUI undo() {
		int code;
		
		String feedbackMsg;
		storage.deleteOneItem(newTask);
		storage.addOneItem(oldTask);
		OutputToUI outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Update", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		return outputToUI;
	}

	@Override
	public OutputToUI redo() {
		int code;
		OutputToUI outputToUI = new OutputToUI();
		String feedbackMsg;
		if (oldTask.equals(new Task())){
			code = 10; 
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum),code));
			return outputToUI;
		}
		//If empty, return feedback msg saying task description cannot be empty
		if (newEndTime.isEmpty()){
			code = 7;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		} else if (newTask.equals(new Task())){
			code = 8;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		}
		if(this.oldRecurTaskGroup.isEmpty()) {
			storage.deleteOneItem(oldTask);
			System.out.println("Ouside empty");
			storage.addOneItem(newTask);
		}
```
###### src\main\java\logic\UpdateEndTime.java
``` java
		outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Update", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		history.pushCommandToUndoList(this);
		return outputToUI;
	}

}
```
###### src\main\java\logic\UpdateName.java
``` java
 */

package main.java.logic;

import java.util.ArrayList;

import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;
/*
 * This class is for update name of the task
 * By creating the command with item number and expected name
 */
public class UpdateName implements Command{

	private Storage storage = Storage.getInstance();
	private String newName;
	private int itemNum;
	private Task oldTask;
	private Task newTask;
	private ArrayList<Task> screenList;
	private History history = History.getInstance();
	private ArrayList<Task> oldRecurTaskGroup = new ArrayList<Task>();
	private ArrayList<Task> newRecurTaskGroup = new ArrayList<Task>();
	
	public UpdateName(int itemNum, String newName ){
		this.newName = newName;
		this.itemNum = itemNum;
		screenList = history.getScreenList();
		this.oldTask = Search.obtainTaskByItemNum(itemNum, screenList);
		if(oldTask.getRecurringID() == 0) {
			newTask = new Task (oldTask.getTaskType(), oldTask.getTaskDescription(), oldTask.getStartDate(), oldTask.getEndDate(),
					oldTask.getStartTime(), oldTask.getEndTime(), oldTask.getIsCompleted(),
					oldTask.getIsDateTimeValid(), oldTask.getRecurringID());
			newTask.setTaskDescription(newName);
		}
```
###### src\main\java\logic\UpdateName.java
``` java
	@Override
	public OutputToUI execute() {
		int code;
		OutputToUI outputToUI= new OutputToUI();
		String feedbackMsg;
		if (oldTask.equals(new Task())){
			code = 10; 
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum),code));
			return outputToUI;
		}
		//If empty, return feedback msg saying task description cannot be empty
		if (newName.isEmpty()){
			code = 2;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		} 
		if(this.oldRecurTaskGroup.isEmpty()) {
			storage.deleteOneItem(oldTask);
			storage.addOneItem(newTask);
		}
```
###### src\main\java\logic\UpdateName.java
``` java
	@Override
	public OutputToUI undo() {
		int code;
		
		String feedbackMsg;
		if(this.oldRecurTaskGroup.isEmpty()) {
			storage.deleteOneItem(newTask);
			storage.addOneItem(oldTask);
		} else  {
			for(int i=0; i<this.newRecurTaskGroup.size(); i++) {
				storage.deleteOneItem(newRecurTaskGroup.get(i));
				storage.addOneItem(oldRecurTaskGroup.get(i));
			}
		}
		OutputToUI outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Update", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		
		return outputToUI;
	}

	@Override
	public OutputToUI redo() {
		int code;
		OutputToUI outputToUI= new OutputToUI();
		String feedbackMsg;
		if (oldTask.equals(new Task())){
			code = 10; 
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum),code));
			return outputToUI;
		}
		//If empty, return feedback msg saying task description cannot be empty
		if (newName.isEmpty()){
			code = 2;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		} 
		if(this.oldRecurTaskGroup.isEmpty()) {
			storage.deleteOneItem(oldTask);
			storage.addOneItem(newTask);
		}
```
###### src\main\java\logic\UpdateStartDate.java
``` java
 */

package main.java.logic;

import java.util.ArrayList;

import main.java.parser.DateAndTime;
import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;
/*
 * This class is for update start date
 * By creating the command with item number and expected date
 */
public class UpdateStartDate implements Command{

	private Storage storage = Storage.getInstance();
	private String newStartDate;
	private int itemNum;
	private Task oldTask;
	private Task newTask;
	private ArrayList<Task> screenList;
	private History history = History.getInstance();
	
	
	public UpdateStartDate(int itemNum, String newStartDate){
		this.newStartDate = newStartDate;
		this.itemNum = itemNum;
		screenList = history.getScreenList();
		this.oldTask = Search.obtainTaskByItemNum(itemNum, screenList);
		if (oldTask.getStartDate().equals("-")||DateAndTime.reformatDate(newStartDate).equals("invalid date format")){
			newTask = new Task();
		} else {
		newTask = new Task (oldTask.getTaskType(), oldTask.getTaskDescription(), oldTask.getStartDate(), oldTask.getEndDate(),
				oldTask.getStartTime(), oldTask.getEndTime(), oldTask.getIsCompleted(),
				oldTask.getIsDateTimeValid(), oldTask.getRecurringID());
		newTask.setStartDate(DateAndTime.reformatDate(newStartDate));
		}
	}
	
	@Override
	public OutputToUI execute() {
		int code;
		OutputToUI outputToUI = new OutputToUI();
		String feedbackMsg;
		if (oldTask.equals(new Task())){
			code = 10; 
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum),code));
			return outputToUI;
		}
		//If empty, return feedback msg saying task description cannot be empty
		if (newStartDate.isEmpty()){
			code = 5;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		} else if (newTask.equals(new Task())){
			code = 6;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		}
		System.out.printf(newStartDate);
		storage.deleteOneItem(oldTask);
		System.out.println("Ouside empty");
		storage.addOneItem(newTask);
		outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Update", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		history.pushCommandToUndoList(this);
		history.clearRedoList();
		return outputToUI;
	}

	@Override
	public OutputToUI undo() {
		int code;
		
		String feedbackMsg;
		storage.deleteOneItem(newTask);
		storage.addOneItem(oldTask);
		OutputToUI outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Update", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		return outputToUI;
	}

	@Override
	public OutputToUI redo() {
		int code;
		OutputToUI outputToUI = new OutputToUI();
		String feedbackMsg;
		if (oldTask.equals(new Task())){
			code = 10; 
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum),code));
			return outputToUI;
		}
		//If empty, return feedback msg saying task description cannot be empty
		if (newStartDate.isEmpty()){
			code = 5;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		} else if (newTask.equals(new Task())){
			code = 6;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		}
		System.out.printf(newStartDate);
		storage.deleteOneItem(oldTask);
		System.out.println("Ouside empty");
		storage.addOneItem(newTask);
		outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Update", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		history.pushCommandToUndoList(this);

		return outputToUI;
	}

}
```
###### src\main\java\logic\UpdateStartTime.java
``` java
 */

package main.java.logic;

import java.util.ArrayList;

import main.java.parser.DateAndTime;
import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;
/*
 * This class is for update start time
 * By creating the command with item number and expected start time
 */
public class UpdateStartTime implements Command{

	private Storage storage = Storage.getInstance();
	private String newStartTime;
	private int itemNum;
	private Task oldTask;
	private Task newTask;
	private ArrayList<Task> screenList;
	private History history = History.getInstance();
	private ArrayList<Task> oldRecurTaskGroup = new ArrayList<Task>();
	private ArrayList<Task> newRecurTaskGroup = new ArrayList<Task>();
	
	public UpdateStartTime(int itemNum, String newStartTime){
		this.newStartTime = newStartTime;
		this.itemNum = itemNum;
		screenList = history.getScreenList();
		this.oldTask = Search.obtainTaskByItemNum(itemNum, screenList);
		if (oldTask.getStartTime().equals("-")||DateAndTime.reformatTime(newStartTime).equals("invalid time format")||!DateAndTime.isValidUpdateST(oldTask, newStartTime)){
			newTask = new Task();
		} else if(oldTask.getRecurringID() == 0) {
			newTask = new Task (oldTask.getTaskType(), oldTask.getTaskDescription(), oldTask.getStartDate(), oldTask.getEndDate(),
					oldTask.getStartTime(), oldTask.getEndTime(), oldTask.getIsCompleted(),
					oldTask.getIsDateTimeValid(), oldTask.getRecurringID());
			newTask.setStartTime(DateAndTime.reformatTime(newStartTime));
		}
```
###### src\main\java\logic\UpdateStartTime.java
``` java
	@Override
	public OutputToUI execute() {
		int code;
		OutputToUI outputToUI = new OutputToUI();
		String feedbackMsg;
		if (oldTask.equals(new Task())){
			code = 10; 
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum),code));
			return outputToUI;
		}
		//If empty, return feedback msg saying task description cannot be empty
		if (newStartTime.isEmpty()){
			code = 3;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		} else if (newTask.equals(new Task())){
			code = 4;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		}
		if(this.oldRecurTaskGroup.isEmpty()) {
			storage.deleteOneItem(oldTask);
			System.out.println("Ouside empty");
			storage.addOneItem(newTask);
		}
```
###### src\main\java\logic\UpdateStartTime.java
``` java
		outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Update", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		history.pushCommandToUndoList(this);
		history.clearRedoList();
		return outputToUI;
	}

	@Override
	public OutputToUI undo() {
		int code;
		
		String feedbackMsg;
		storage.deleteOneItem(newTask);
		storage.addOneItem(oldTask);
		OutputToUI outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Update", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		return outputToUI;
	}

	@Override
	public OutputToUI redo() {
		int code;
		OutputToUI outputToUI = new OutputToUI();
		String feedbackMsg;
		if (oldTask.equals(new Task())){
			code = 10; 
			outputToUI = Controller.refreshScreen();
			outputToUI.setFeedbackMsg(DataDisplay.feedback(String.valueOf(itemNum),code));
			return outputToUI;
		}
		//If empty, return feedback msg saying task description cannot be empty
		if (newStartTime.isEmpty()){
			code = 3;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		} else if (newTask.equals(new Task())){
			code = 4;
			feedbackMsg = DataDisplay.feedback("Update", code);
			outputToUI.setFeedbackMsg(feedbackMsg);
			return outputToUI;
		}
		if(this.oldRecurTaskGroup.isEmpty()) {
			storage.deleteOneItem(oldTask);
			System.out.println("Ouside empty");
			storage.addOneItem(newTask);
		}
```
###### src\main\java\logic\UpdateStartTime.java
``` java
		outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Update", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		history.pushCommandToUndoList(this);
		return outputToUI;
	}

}
```
###### src\main\java\resources\DataDisplay.java
``` java
 */

package main.java.resources;

import java.util.ArrayList;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;

import main.java.logic.Command;
import main.java.logic.History;
/*
 * This class is for display various informations
 * By creating the result by various different input
 */
public class DataDisplay {

	private static final Logger log = Logger.getLogger( DataDisplay.class.getName() );
	private static final String TASK_TYPE_FLOATING_LOWERCASE = "floating";
	private static final String TASK_TYPE_EVENT_LOWERCASE = "event";
	private static final String TASK_TYPE_DEADLINE_LOWERCASE = "deadline";
	private static final String KEYWORD_ADD = "add";
	private static final String KEYWORD_FROM =" from ";
	private static final String KEYWORD_UPPER_FROM ="From ";
	private static final String KEYWORD_TO =" to ";
	private static final String KEYWORD_BY = " by ";
	private static final String REGEX_COLON = ": ";
	private static final String REGEX_SEMICOLON = ";";
	private static final String REGEX_COMMA =", ";
	

	// To display a given list of task in order
	public static ArrayList<String> displayList(ArrayList<Task> listForPrint) {
		log.log(Level.INFO, "start to display task list");
		ArrayList<String> outputForTesting = new ArrayList<String>();
		if (listForPrint.isEmpty()) {
			log.log(Level.WARNING, "No task. Please enter one to start");
		} else {
			for (int i = 0; i < listForPrint.size(); i++) {
				assert listForPrint.size() > 0; //Make sure there are sth to print
				int itemNum = i + 1;
				switch (listForPrint.get(i).getTaskType().toLowerCase()) {
				case TASK_TYPE_DEADLINE_LOWERCASE:
					log.log(Level.INFO, itemNum + REGEX_COLON + createContentForDeadline(listForPrint.get(i)));
					outputForTesting.add(itemNum + REGEX_COLON + createContentForDeadline(listForPrint.get(i)));
					break;
				case TASK_TYPE_EVENT_LOWERCASE:
					log.log(Level.INFO, itemNum + REGEX_COLON + createContentForEvent(listForPrint.get(i)));
					outputForTesting.add(itemNum + REGEX_COLON + createContentForEvent(listForPrint.get(i)));
					break;
				case TASK_TYPE_FLOATING_LOWERCASE:
					log.log(Level.INFO, itemNum + REGEX_COLON + createContentForFloating(listForPrint.get(i)));
					outputForTesting.add(itemNum + REGEX_COLON + createContentForFloating(listForPrint.get(i)));
					break;
				default:
					log.log(Level.WARNING, "task type is invalid");
					break;
				}
			}
		}
		return outputForTesting;
	}

	// get a strig to display on input box to ask user to update accordingly

	public static String displayTaskNeedForUpdate(Task task) {
		log.log(Level.INFO, "start to display the task for update");
		String outputForTesting = "";
		switch (task.getTaskType()) {
		case TASK_TYPE_DEADLINE_LOWERCASE:
			log.log(Level.INFO,KEYWORD_ADD + updateContentForDeadline(task));
			outputForTesting = KEYWORD_ADD + updateContentForDeadline(task);
			break;
		case TASK_TYPE_FLOATING_LOWERCASE:
			log.log(Level.INFO,KEYWORD_ADD + updateContentForFloating(task));
			outputForTesting = KEYWORD_ADD + updateContentForFloating(task);
			break;
		case TASK_TYPE_EVENT_LOWERCASE:
			log.log(Level.INFO,KEYWORD_ADD + updateContentForEvent(task));
			outputForTesting = KEYWORD_ADD + updateContentForEvent(task);
			break;
		default:
			log.log(Level.WARNING,"task type is invalid");
		}
		return outputForTesting;
	}

	private static String updateContentForDeadline(Task task) {
		log.log(Level.INFO,"update Content For Deadline");
		return task.getTaskDescription() + KEYWORD_BY + task.getEndDate() + REGEX_SEMICOLON + task.getEndTime();
	}

	private static String updateContentForFloating(Task task) {
		log.log(Level.INFO,"update Content For Floating");
		return createContentForFloating(task);
	}

	private static String updateContentForEvent(Task task) {
		log.log(Level.INFO,"update Content For Event");
		return task.getTaskDescription() + KEYWORD_FROM + task.getStartDate() + REGEX_SEMICOLON + task.getStartTime() + " to "
				+ task.getEndDate() + REGEX_SEMICOLON + task.getEndTime();
	}

	private static String createContentForFloating(Task task) {
		log.log(Level.INFO,"create Content For Floating");
		return task.getTaskDescription();
	}

	private static String createContentForEvent(Task task) {
		log.log(Level.INFO,"create Content For Event");
		if (task.getEndTime().equals("-")){
			return KEYWORD_UPPER_FROM  + task.getStartDate() + KEYWORD_TO
					+ task.getEndDate() + REGEX_COLON + task.getTaskDescription();
		}
		return KEYWORD_UPPER_FROM + task.getStartTime() + REGEX_COMMA + task.getStartDate() + KEYWORD_TO + task.getEndTime() + ", "
				+ task.getEndDate() + REGEX_COLON + task.getTaskDescription();
	}

	private static String createContentForDeadline(Task task) {
		log.log(Level.INFO,"create Content For Deadline");
		if (task.getEndTime().equals("-")){
			return KEYWORD_BY + task.getEndDate() + REGEX_COLON + task.getTaskDescription();
		} 

		
		return KEYWORD_BY + task.getEndTime() + REGEX_COMMA + task.getEndDate() + REGEX_COLON + task.getTaskDescription();
	}

	
	//give out different feedback for the user to see
	public static String feedback(String action, int code) {
		// Code = 0: success
		String feedbackMsg="";

		if (code == 0) {
			feedbackMsg = action + " is successful";
			log.log(Level.INFO,feedbackMsg);
			return feedbackMsg;	
		}else if (code == 1){
            feedbackMsg = action + " is not a valid format, please refer to HELP for the correct format";
            log.log(Level.INFO,feedbackMsg);
			return feedbackMsg;
		}else if (code == 2){
			feedbackMsg = action + " is not successful. Task description cannot be empty.";
			log.log(Level.INFO,feedbackMsg);
			return feedbackMsg;
		}else if (code == 3){
			feedbackMsg = action + " is not successful. Task start time cannot be empty.";
			log.log(Level.INFO,feedbackMsg);
			return feedbackMsg;
		}else if (code == 4){
			feedbackMsg = action + " is not successful. No start time for this task or the new time is not a valid format.";
			log.log(Level.INFO,feedbackMsg);
			return feedbackMsg;
		}else if (code == 5){
			feedbackMsg = action + " is not successful. Task start date cannot be empty.";
			log.log(Level.INFO,feedbackMsg);
			return feedbackMsg;
		}else if (code == 6){
			feedbackMsg = action + " is not successful. No start date for this task or the new date is not a valid format.";
			log.log(Level.INFO,feedbackMsg);
			return feedbackMsg;
		}else if (code == 7){
			feedbackMsg = action + " is not successful. Task end time cannot be empty.";
			log.log(Level.INFO,feedbackMsg);
			return feedbackMsg;
		}else if (code == 8){
			feedbackMsg = action + " is not successful. No end time for this task or the new time is not a valid format.";
			log.log(Level.INFO,feedbackMsg);
			return feedbackMsg;
		}else if (code == 9){
			feedbackMsg = action + " is not successful. There is no task to be " + action.toLowerCase() + "ne" ;
			log.log(Level.INFO,feedbackMsg);
			return feedbackMsg;
		}else if (code == 10){
			feedbackMsg = "Unsuccessful. There is no task No. " + action + " on screen" ;
			log.log(Level.INFO,feedbackMsg);
			return feedbackMsg;
		}else if (code == 11){
			feedbackMsg = "Delete recurring tasks is not successful, task No. "+ action + " is not a recurring task" ;
			log.log(Level.INFO,feedbackMsg);
			return feedbackMsg;
		}else if (code < 0){
			feedbackMsg = action + " is not successful, please enter the correct format";
			log.log(Level.INFO,feedbackMsg);
		}else 
			log.log(Level.WARNING, "feedback code is invalid");
			
		return feedbackMsg;
	}

	// For testing, to print info in outputToUI
	public static void printOutputToUI(OutputToUI outputToUI) {
		ArrayList<ItemForUserScreen> itemList = outputToUI.getItemList();
		System.out.println("typeOfScreen: " + outputToUI.getTypeOfScreen());
		System.out.println("ItemList: ");
		if (itemList == null) {
			System.out.println("ItemList is empty");
		} else {
			for (int i = 0; i < itemList.size(); i++) {
				System.out.println(itemList.get(i).getIfComplete() + "_" + itemList.get(i).getTaskType() + "_"
						+ itemList.get(i).getPrintOnScreenMsg());
			}
		}
		System.out.println("FeedbackMsg: " + outputToUI.getFeedbackMsg());
		System.out.println("inputBoxMsg: " + outputToUI.getInputBoxMsg());
	}
	
	//for testing, to print the command content
	public static void printUndoCommandList(){
		History history = History.getInstance();
		Stack<Command> undoCommandList = history.getUndoCommandList();
		System.out.println("Printing undo List:");
		int size = undoCommandList.size();
		for (int i = 0; i < size; i++){
			Command command = undoCommandList.get(i);
			System.out.println(command);
		}
	}
	
	public static void printRedoCommandList(){
		History history = History.getInstance();
		Stack<Command> redoCommandList = history.getRedoCommandList();
		System.out.println("Printing redo List:");
		int size = redoCommandList.size();
		for (int i = 0; i < size; i++){
			Command command = redoCommandList.get(i);
			System.out.println(command);
		}
	}
	
	/*
```
###### src\main\java\resources\ItemForUserScreen.java
``` java
 */

package main.java.resources;

/*
 * This class is for create a list for the user screen display
 * So the screen information can be refreshed with a standard format, which is the one in this class
 * By using information on the tasks from the tasklist to be displayed
 */
public class ItemForUserScreen {
	private boolean ifComplete;
	private String taskType;
	private String printOnScreenMsg;

	public ItemForUserScreen(boolean ifComplete, String taskType, String printOnScreenMsg) {
		this.ifComplete = ifComplete;
		this.taskType = taskType;
		this.printOnScreenMsg = printOnScreenMsg;
	}

	// Accessor
	public boolean getIfComplete() {
		return ifComplete;
	}

	public String getTaskType() {
		return taskType;
	}
	
	public String getPrintOnScreenMsg(){
		return printOnScreenMsg;
	}
	
}
```
###### src\main\java\resources\OutputToUI.java
``` java
 */

package main.java.resources;

import java.util.ArrayList;
/*
 * This class is for update the UI for neccessary information to be display in different locations
 * So the UI can know what to do and what to display everytime after a commend is executed
 */
public class OutputToUI {
	private String typeOfScreen;
	private ArrayList<ItemForUserScreen> itemList;
	private String feedbackMsg;
	private String inputBoxMsg;
	
	public OutputToUI (){
		typeOfScreen = null;
		itemList = null;
		feedbackMsg = null;
		inputBoxMsg = null;
	}
	
	public OutputToUI(String typeOfScreen, ArrayList<ItemForUserScreen> itemList, String feedbackMsg,
			String inputBoxMsg) {
		this.typeOfScreen = typeOfScreen;
		this.itemList = itemList;
		this.feedbackMsg = feedbackMsg;
		this.inputBoxMsg = inputBoxMsg;
	}
	
	//Accessor
	public String getTypeOfScreen(){
		return typeOfScreen;
	}
	
	public ArrayList<ItemForUserScreen> getItemList(){
		return itemList;
	}
	
	public String getFeedbackMsg(){
		return feedbackMsg;
	}
	
	public String getInputBoxMsg(){
		return inputBoxMsg;
	}
	
	//mutator
	public void setTypeOfScreen(String typeOfScreen){
		this.typeOfScreen = typeOfScreen;
	}
	
	public void setItemList(ArrayList<ItemForUserScreen> itemList){
		this.itemList = itemList;
	}
	
	public void setFeedbackMsg(String feedbackMsg){
		this.feedbackMsg = feedbackMsg;
	}
	
	public void setInputBoxMsg(String inputBoxMsg){
		this.inputBoxMsg = inputBoxMsg;
	}
}
```
###### src\main\java\resources\TaskComparator.java
``` java
 */

package main.java.resources;
/*
 * This class is for the sort.java to use to sort all tasks in a necessary order
 * It goes in an order of date, time and string alphabet
 */
import java.util.Comparator;

import main.java.logic.Sort;

//comparator that compare iscomplete first then time, then task content string
public class TaskComparator implements Comparator<Sort> {

	@Override
	public int compare(Sort sort1, Sort sort2) {

		int dateResult = sort1.getTaskDate().compareTo(sort2.getTaskDate());
		if (dateResult != 0) {
			return dateResult;
		} else {
			int timeResult = sort1.getTaskTime().compareTo(sort2.getTaskTime());
			if (timeResult != 0) {
				return timeResult;
			} else {
				return sort1.getTaskContent().compareTo(sort2.getTaskContent());
			}
		}
	}

	//author a0104278-unused
	//Due to change of plan
	/*
	 * 
	 * public static final String TYPE_DEADLINE = "deadline"; public static
	 * final String TYPE_EVENT = "event"; public static final String
	 * TYPE_FLOATING = "floating";
	 * 
	 * static Task task1 = new Task(TYPE_DEADLINE, "wake up", null,
	 * "01/01/2015", null, "0900", false); static Task task2 = new
	 * Task(TYPE_DEADLINE, "wash face with cool water", null, "02/02/2015",
	 * null, "1100", true); static Task task3 = new Task(TYPE_EVENT, "go toilet"
	 * , "01/01/2015", "01/02/2015", "0900", "1000", false); static Task task4 =
	 * new Task(TYPE_EVENT, "wash hand with soap", "03/02/2015", "03/02/2015",
	 * "0915", "1100", true); static Task task5 = new Task(TYPE_FLOATING,
	 * "meet with bob", null, null, null, null, false); static Task task6 = new
	 * Task(TYPE_FLOATING, "eat breakfast", null, null, null, null, true);
	 * 
	 * public static void main(String arg[]){ ArrayList<Task> taskList = new
	 * ArrayList<Task>(); taskList.add(task1); taskList.add(task3);
	 * taskList.add(task6); taskList.add(task4); taskList.add(task5);
	 * taskList.add(task2); Collections.sort(taskList, new TaskComparator());
	 * DataDisplay.displayList(taskList); }
	 */

	/*
	 * @Override public int compare(Sort sort1, Sort sort2) { int completeResult
	 * = sort1.getIsComplete().compareTo(sort2.getIsComplete()); if
	 * (completeResult != 0){ return completeResult; } int timeResult =
	 * sort1.getTaskTime().compareTo(sort2.getTaskTime()); if (timeResult != 0){
	 * return timeResult; } int stringResult =
	 * sort1.getTaskContent().compareTo(sort2.getTaskContent()); return
	 * stringResult; }
	 * 
	 * public static void main(String arg[]){ ArrayList<Task> sortResult = new
	 * ArrayList<Task> (); ArrayList<Sort> sortList =
	 * createSortList(listForSort); Collections.sort(sortList, new
	 * TaskComparator()); for (int i = 0; i <sortList.size(); i++){
	 * sortResult.add(sortList.get(i).getTask()); } }
	 */

}
```
###### src\test\logic\AddTest.java
``` java
 */

package test.logic;

import static org.junit.Assert.*;

import java.io.IOException;

import org.junit.Test;

import main.java.logic.Add;
import main.java.logic.Command;
import main.java.logic.Controller;
import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;

public class AddTest {
	public static final String TYPE_DEADLINE = "deadline";
	public static final String TYPE_EVENT = "event";
	public static final String TYPE_FLOATING = "floating";
	
	Task task1 = new Task(TYPE_DEADLINE, "wake up", "-", "01/01/2015", "-", "0900", false, true, 0);
	Task task2 = new Task(TYPE_DEADLINE, "wash face with cool water", "-", "02/02/2015", "null", "1100", true, true, 0);
	Task task3 = new Task(TYPE_EVENT, "go toilet", "01/01/2015", "01/02/2015", "0900", "1000", false, true, 0);
	Task task4 = new Task(TYPE_EVENT, "wash hand with soap", "03/02/2015", "03/02/2015", "0915", "1100", true, true, 0);
	Task task5 = new Task(TYPE_FLOATING, "meet with bob", "-", "-", "-", "-", false, true, 0);
	Task task6 = new Task(TYPE_FLOATING, "eat breakfast", "-", "-", "-", "-", true, true, 0);
	Task task7 = new Task(TYPE_DEADLINE, "wake up", "-", "01/01/2015", "-", "0900", false, true, 0);	
	Storage storage = Storage.getInstance();
	Command command1 = new Add(task1, storage);
	Command command2 = new Add(task2, storage);
	Command command3 = new Add(task3, storage);
	Command command4 = new Add(task4, storage);
	public OutputToUI outputToUI = new OutputToUI();
	
	//Test only when external file is empty
	@Test
	public void test() throws IOException {
		Controller.initializeProgram();
		command1.execute();
		command2.execute();
		command3.execute();
		outputToUI = command4.execute();
		DataDisplay.printOutputToUI(outputToUI);
		DataDisplay.displayList(storage.getTaskList());
		assertTrue(storage.getTaskList().contains(task1));
		
	}

}
```
###### src\test\logic\CompleteTest.java
``` java
 */

package test.logic;

import static org.junit.Assert.*;

import java.io.IOException;

import org.junit.Test;

import main.java.logic.Add;
import main.java.logic.Command;
import main.java.logic.Complete;
import main.java.logic.Controller;
import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;

public class CompleteTest {
	public static final String TYPE_DEADLINE = "deadline";
	public static final String TYPE_EVENT = "event";
	public static final String TYPE_FLOATING = "floating";
	
	Task task1 = new Task(TYPE_DEADLINE, "wake up", "-", "01/01/2015", "-", "0900", false, true, 0);
	Task task2 = new Task(TYPE_DEADLINE, "wash face with cool water", "-", "02/02/2015", "null", "1100", true, true, 0);
	Task task3 = new Task(TYPE_EVENT, "go toilet", "01/01/2015", "01/02/2015", "0900", "1000", false, true, 0);
	Task task4 = new Task(TYPE_EVENT, "wash hand with soap", "03/02/2015", "03/02/2015", "0915", "1100", true, true, 0);
	Task task5 = new Task(TYPE_FLOATING, "meet with bob", "-", "-", "-", "-", false, true, 0);
	Task task6 = new Task(TYPE_FLOATING, "eat breakfast", "-", "-", "-", "-", true, true, 0);
	Task task7 = new Task(TYPE_DEADLINE, "wake up", "-", "01/01/2015", "-", "0900", false, true, 0);	
	
	Storage storage = Storage.getInstance();
	Command command1 = new Add(task1, storage);
	Command command2 = new Add(task2, storage);
	Command command3 = new Add(task3, storage);
	Command command4 = new Add(task4, storage);
	Command command5 = new Add(task5, storage);
	Command command6 = new Add(task6, storage);
	Command displayCommand = Controller.createCommand("display all");
	int itemNum = 5;
	
	//Test only when external file is empty
	@Test
	public void test() throws IOException {
		Controller.initializeProgram();
		storage.getTaskList().clear();
		DataDisplay.displayList(storage.getTaskList());
		command1.execute();
		command2.execute();
		command3.execute();
		command4.execute();
		command5.execute();
		command6.execute();
		OutputToUI outputToUI=displayCommand.execute();
		DataDisplay.printOutputToUI(outputToUI);
		//DataDisplay.displayList(storage.getTaskList());
		Command command_update = new Complete(itemNum, storage);
		OutputToUI outputToUI2=command_update.execute();
		DataDisplay.displayList(storage.getTaskList());
		DataDisplay.printOutputToUI(outputToUI2);
		task7.setCompleted(true);
		OutputToUI outputToUI3=displayCommand.execute();
		DataDisplay.printOutputToUI(outputToUI3);
		System.out.println(task7.getIsCompleted());
		assertTrue(storage.getTaskList().contains(task7));
	}

}
```
###### src\test\logic\DeleteTest.java
``` java
 */

package test.logic;

import static org.junit.Assert.*;

import java.io.IOException;

import org.junit.Test;

import main.java.logic.Add;
import main.java.logic.Command;
import main.java.logic.Controller;
import main.java.logic.Delete;
import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;

public class DeleteTest {
	public static final String TYPE_DEADLINE = "deadline";
	public static final String TYPE_EVENT = "event";
	public static final String TYPE_FLOATING = "floating";
	
	Task task1 = new Task(TYPE_DEADLINE, "wake up", "-", "01/01/2015", "-", "0900", false, true, 0);
	Task task2 = new Task(TYPE_DEADLINE, "wash face with cool water", "-", "02/02/2015", "null", "1100", true, true, 0);
	Task task3 = new Task(TYPE_EVENT, "go toilet", "01/01/2015", "01/02/2015", "0900", "1000", false, true, 0);
	Task task4 = new Task(TYPE_EVENT, "wash hand with soap", "03/02/2015", "03/02/2015", "0915", "1100", true, true, 0);
	Task task5 = new Task(TYPE_FLOATING, "meet with bob", "-", "-", "-", "-", false, true, 0);
	Task task6 = new Task(TYPE_FLOATING, "eat breakfast", "-", "-", "-", "-", true, true, 0);
	Task task7 = new Task(TYPE_DEADLINE, "wake up", "-", "01/01/2015", "-", "0900", false, true, 0);	
	
	Storage storage = Storage.getInstance();

	Command command1 = new Add(task1, storage);
	Command command2 = new Add(task2, storage);
	Command command3 = new Add(task3, storage);
	Command command4 = new Add(task4, storage);
	int itemNum = 1;
	String deleteType = "";
	Command displayCommand = Controller.createCommand("display all");

	//Test only when external file is empty
	@Test
	public void test() throws IOException {
		Controller.initializeProgram();
		storage.getTaskList().clear();
		DataDisplay.displayList(storage.getTaskList());
		command1.execute();
		command2.execute();
		command3.execute();
		command4.execute();
		OutputToUI outputToUI=displayCommand.execute();
		DataDisplay.printOutputToUI(outputToUI);
		//DataDisplay.displayList(storage.getTaskList());
		Command command_del = new Delete(itemNum, deleteType, storage);
		command_del.execute();
		DataDisplay.displayList(storage.getTaskList());
		assertTrue(!storage.getTaskList().contains(task2));
	}

}
```
###### src\test\logic\DisplayTest.java
``` java
 */

package test.logic;

import java.io.IOException;

import org.junit.Test;

import main.java.logic.Add;
import main.java.logic.Command;
import main.java.logic.Controller;
import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;

public class DisplayTest {
	public static final String TYPE_DEADLINE = "deadline";
	public static final String TYPE_EVENT = "event";
	public static final String TYPE_FLOATING = "floating";
	

	Task task1 = new Task(TYPE_DEADLINE, "wake up", "-", "01/01/2015", "-", "0900", false, true, 0);
	Task task2 = new Task(TYPE_DEADLINE, "wash face with cool water", "-", "02/02/2015", "null", "1100", true, true, 0);
	Task task3 = new Task(TYPE_EVENT, "go toilet", "01/01/2015", "01/02/2015", "0900", "1000", false, true, 0);
	Task task4 = new Task(TYPE_EVENT, "wash hand with soap", "03/02/2015", "03/02/2015", "0915", "1100", true, true, 0);
	Task task5 = new Task(TYPE_FLOATING, "meet with bob", "-", "-", "-", "-", false, true, 0);
	Task task6 = new Task(TYPE_FLOATING, "eat breakfast", "-", "-", "-", "-", true, true, 0);
	Task task7 = new Task(TYPE_DEADLINE, "wake up", "-", "01/01/2015", "-", "0900", false, true, 0);	
	
	Storage storage = Storage.getInstance();
	Command command1 = new Add(task1, storage);
	Command command2 = new Add(task2, storage);
	Command command3 = new Add(task3, storage);
	Command command4 = new Add(task4, storage);
	Command command5 = new Add(task5, storage);
	Command command6 = new Add(task6, storage);
	//Command displayCommand = Controller.createCommand("display today");
	//ArrayList<String> inputForAction = new ArrayList<String>();
	Command displayCommand = Controller.createCommand("display all");
	public OutputToUI outputToUI = new OutputToUI();
	
	//Test only when external file is empty
	@Test
	public void test() throws IOException {
		/*inputForAction.add("display");
		inputForAction.add("incomplete");
		Command displayCommand = new Display(inputForAction, storage);*/
		Controller.initializeProgram();
		command1.execute();
		command2.execute();
		command3.execute();
		command4.execute();
		command5.execute();
		command6.execute();
		outputToUI = displayCommand.execute();
		DataDisplay.printOutputToUI(outputToUI);
	}

}
```
###### src\test\logic\IncompleteTest.java
``` java
 */

package test.logic;

import static org.junit.Assert.*;

import java.io.IOException;

import org.junit.Test;

import main.java.logic.Add;
import main.java.logic.Command;
import main.java.logic.Controller;
import main.java.logic.Incomplete;
import main.java.resources.DataDisplay;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;

public class IncompleteTest {

	public static final String TYPE_DEADLINE = "deadline";
	public static final String TYPE_EVENT = "event";
	public static final String TYPE_FLOATING = "floating";
	
	Task task1 = new Task(TYPE_DEADLINE, "wake up", "-", "01/01/2015", "-", "0900", false, true, 0);
	Task task2 = new Task(TYPE_DEADLINE, "wash face with cool water", "-", "02/02/2015", "null", "1100", true, true, 0);
	Task task3 = new Task(TYPE_EVENT, "go toilet", "01/01/2015", "01/02/2015", "0900", "1000", false, true, 0);
	Task task4 = new Task(TYPE_EVENT, "wash hand with soap", "03/02/2015", "03/02/2015", "0915", "1100", true, true, 0);
	Task task5 = new Task(TYPE_FLOATING, "meet with bob", "-", "-", "-", "-", false, true, 0);
	Task task6 = new Task(TYPE_FLOATING, "eat breakfast", "-", "-", "-", "-", true, true, 0);
	Task task7 = new Task(TYPE_DEADLINE, "wake up", "-", "01/01/2015", "-", "0900", false, true, 0);	
	
	Task task8 = new Task(TYPE_EVENT, "wash hand with soap", "03/02/2015", "03/02/2015", "0915", "1100", false, true, 0);
	
	Storage storage = Storage.getInstance();
	Command command1 = new Add(task1, storage);
	Command command2 = new Add(task2, storage);
	Command command3 = new Add(task3, storage);
	Command command4 = new Add(task4, storage);
	Command command5 = new Add(task5, storage);
	Command command6 = new Add(task6, storage);
	Command displayCommand = Controller.createCommand("display all");
	int itemNum = 2;
	
	//Test only when external file is empty
	@Test
	public void test() throws IOException {
		Controller.initializeProgram();
		storage.getTaskList().clear();
		DataDisplay.displayList(storage.getTaskList());
		command1.execute();
		command2.execute();
		command3.execute();
		command4.execute();
		command5.execute();
		command6.execute();
		OutputToUI outputToUI=displayCommand.execute();
		DataDisplay.printOutputToUI(outputToUI);
		//DataDisplay.displayList(storage.getTaskList());
		Command command_incomplete = new Incomplete(itemNum, storage);
		OutputToUI outputToUI2=command_incomplete.execute();
		DataDisplay.displayList(storage.getTaskList());
		DataDisplay.printOutputToUI(outputToUI2);
		task8.setCompleted(false);
		OutputToUI outputToUI3=displayCommand.execute();
		DataDisplay.printOutputToUI(outputToUI3);
		System.out.println(task2.getIsCompleted());
		assertTrue(storage.getTaskList().contains(task8));
	}
}
```
###### src\test\logic\TestOut.java
``` java
 */

package test.logic;

import java.util.ArrayList;

public class TestOut {

	private int num;
	private String str;

	public TestOut(int num, String str) {
		this.num = num;
		this.str = str;
	}

	public int getNum() {
		return num;
	}

	public String getStr() {
		return str;
	}

	@Override
	public boolean equals(Object object) {
		boolean result = false;
		if (object != null && object instanceof TestOut) {
			result = this.getNum() == ((TestOut) object).getNum() && this.getStr().equals(((TestOut) object).getStr());
		}

		return result;

	}

	public static void main(String[] args) {

		TestOut out = new TestOut(1, "2");
		ArrayList<TestOut> list = new ArrayList<TestOut>();
		list.add(out);
		TestOut out2 = new TestOut(1, "2");

		if (list.contains(out2)) {
			System.out.println("they are equal");
		}

	}

}
```
###### src\test\logic\testStorage.java
``` java
 */

package test.logic;

import java.util.ArrayList;

import main.java.resources.Task;

public class testStorage {

	private static ArrayList<Task> list = new ArrayList<Task>();;
	
	public testStorage(){
	}
	
	
	public static void addOneItem(Task task) {
		list.add(task);
		
	}


	public ArrayList<Task> getTaskList() {
		// TODO Auto-generated method stub
		return list;
	}


	public static void deleteOneItem(int itemNum) {
		list.remove(itemNum-1);
		
	}

}
```
###### src\test\logic\UpdateTest.java
``` java
 */

package test.logic;

import main.java.logic.Add;
import main.java.logic.Command;
import main.java.logic.Controller;
import main.java.resources.Task;
import main.java.storage.Storage;

public class UpdateTest {
	public static final String TYPE_DEADLINE = "deadline";
	public static final String TYPE_EVENT = "event";
	public static final String TYPE_FLOATING = "floating";
	
	Task task1 = new Task(TYPE_DEADLINE, "wake up", "null", "01/01/2015", "null", "0900", false, false, 0);
	Task task2 = new Task(TYPE_DEADLINE, "wash face with cool water", "null", "02/02/2015", "null", "1100", true, false, 0);
	Task task3 = new Task(TYPE_EVENT, "go toilet", "01/01/2015", "01/02/2015", "0900", "1000", false, false, 0);
	Task task4 = new Task(TYPE_EVENT, "wash hand with soap", "03/02/2015", "03/02/2015", "0915", "1100", true, false, 0);
	Task task5 = new Task(TYPE_FLOATING, "meet with bob", "null", "null", "null", "null", false, false, 0);
	Task task6 = new Task(TYPE_FLOATING, "eat breakfast", "null", "null", "null", "null", true, false, 0);
	Task task7 = new Task(TYPE_DEADLINE, "wake up", "null", "01/01/2015", "null", "0900", false, false, 0);	
	Storage storage = Storage.getInstance();
	Command command1 = new Add(task1, storage);
	Command command2 = new Add(task2, storage);
	Command command3 = new Add(task3, storage);
	Command command4 = new Add(task4, storage);
	Command command5 = new Add(task5, storage);
	Command command6 = new Add(task6, storage);
	int itemNum = 1;
	Command displayCommand = Controller.createCommand("display all");
	
/*	@Test
	public void test() throws IOException {
		Controller.initializeProgram();
		DataDisplay.displayList(storage.getTaskList());
		command1.execute();
		command2.execute();
		command3.execute();
		command4.execute();
		OutputToUI outputToUI=displayCommand.execute();
		DataDisplay.printOutputToUI(outputToUI);
		//DataDisplay.displayList(storage.getTaskList());
		Command command_update = new Update(itemNum, storage);
		OutputToUI outputToUI2=command_update.execute();
		DataDisplay.displayList(storage.getTaskList());
		DataDisplay.printOutputToUI(outputToUI2);
		assertTrue(!storage.getTaskList().contains(task1));
	}
*/
}
```
###### src\test\resources\DataDisplayTest.java
``` java
 */

package test.resources;

import java.util.ArrayList;
import main.java.resources.Task;

public class DataDisplayTest {
	public static final String TYPE_DEADLINE = "deadline";
	public static final String TYPE_EVENT = "event";
	public static final String TYPE_FLOATING = "floating";

	// initialize different task object that fits different requirement

	Task task1 = new Task(TYPE_DEADLINE, "wake up", "null", "01/01/2015", "null", "0900", false, false, 0);
	Task task2 = new Task(TYPE_DEADLINE, "wash face with cool water", "null", "02/02/2015", "null", "1100", true, false, 0);
	Task task3 = new Task(TYPE_EVENT, "go toilet", "01/01/2015", "01/02/2015", "0900", "1000", false, false, 0);
	Task task4 = new Task(TYPE_EVENT, "wash hand with soap", "03/02/2015", "03/02/2015", "0915", "1100", true, false, 0);
	Task task5 = new Task(TYPE_FLOATING, "meet with bob", "null", "null", "null", "null", false, false, 0);
	Task task6 = new Task(TYPE_FLOATING, "eat breakfast", "null", "null", "null", "null", true, false, 0);
	Task task7 = new Task(TYPE_DEADLINE, "wake up", "null", "01/01/2015", "null", "0900", false, false, 0);	
	
	// expected print format for each task
	String task1Print = "By 0900, 01/01/2015: wake up";
	String task2Print = "By 1100, 02/02/2015: wash face with cool water";
	String task3Print = "From 0900, 01/01/2015 to 1000, 01/02/2015: go toilet";
	String task4Print = "From 0915, 03/02/2015 to 1100, 03/02/2015: wash hand with soap";
	String task5Print = "meet with bob";
	String task6Print = "eat breakfast";

	// initialize different list for print
	ArrayList<Task> summaryList = new ArrayList<Task>();
	ArrayList<Task> incompleteList = new ArrayList<Task>();
	ArrayList<Task> completeList = new ArrayList<Task>();
	ArrayList<Task> floatingList = new ArrayList<Task>();
	ArrayList<Task> deadlineList = new ArrayList<Task>();
	ArrayList<Task> eventList = new ArrayList<Task>();

	// not used due to the change in screen listview
	/*@Test
	// Task Type count
	public void testTaskTypeCountFunction() {
		summaryList.add(task1);
		summaryList.add(task3);
		summaryList.add(task5);
		ArrayList<Integer> expected = new ArrayList<Integer>();
		expected.add(1);
		expected.add(1);
		expected.add(1);

		testTaskTypeCount(expected, summaryList);
	}

	private void testTaskTypeCount(ArrayList<Integer> expected, ArrayList<Task> summaryList) {
		assertEquals(expected, DataDisplay.countTaskTypeNum(summaryList));

	}

	@Test
	// Display summary
	public void testDisplaySummaryFunction() {
		summaryList.add(task1);
		summaryList.add(task3);
		summaryList.add(task5);
		ArrayList<String> expected = new ArrayList<String>();
		//expected.add("Deadline");
		expected.add("1: " + task1Print);
		//expected.add("Event");
		expected.add("2: " + task3Print);
		//expected.add("Floating");
		expected.add("3: " + task5Print);

		testDisplaySummary(expected, summaryList);

	}

	private void testDisplaySummary(ArrayList<String> expected, ArrayList<Task> summaryList) {
		assertEquals(expected, DataDisplay.displaySummary(summaryList));

	}

	@Test
	// Display complete list
	public void testDisplayCompleteFunction() {
		completeList.add(task2);
		completeList.add(task4);
		completeList.add(task6);
		ArrayList<String> expected = new ArrayList<String>();
		expected.add("1: " + task2Print);
		expected.add("2: " + task4Print);
		expected.add("3: " + task6Print);

		testDisplayComplete(expected, completeList);
	}

	private void testDisplayComplete(ArrayList<String> expected, ArrayList<Task> completeList) {
		assertEquals(expected, DataDisplay.displayComplete(completeList));

	}

	@Test
	// Display incomplete list
	public void testDisplayIncompleteFunction() {
		incompleteList.add(task1);
		incompleteList.add(task3);
		incompleteList.add(task5);
		ArrayList<String> expected = new ArrayList<String>();
		//expected.add("Incomplete");
		expected.add("1: " + task1Print);
		expected.add("2: " + task3Print);
		expected.add("3: " + task5Print);

		testDisplayIncomplete(expected, incompleteList);
	}

	private void testDisplayIncomplete(ArrayList<String> expected, ArrayList<Task> incompleteList) {
		assertEquals(expected, DataDisplay.displayIncomplete(incompleteList));

	}

	@Test
	// Display floating list
	public void testDisplayFloatingFunction() {
		floatingList.add(task5);
		floatingList.add(task6);
		ArrayList<String> expected = new ArrayList<String>();
		//expected.add("Floating");
		expected.add("1: " + task5Print);
		expected.add("2: " + task6Print);

		testDisplayFloating(expected, floatingList);
	}

	private void testDisplayFloating(ArrayList<String> expected, ArrayList<Task> floatingList) {
		assertEquals(expected, DataDisplay.displayFloating(floatingList));

	}

	@Test
	// Display event list
	public void testDisplayEventFunction() {
		eventList.add(task4);
		eventList.add(task3);
		ArrayList<String> expected = new ArrayList<String>();
		//expected.add("Event");
		expected.add("1: " + task4Print);
		expected.add("2: " + task3Print);

		testDisplayEvent(expected, eventList);
	}

	private void testDisplayEvent(ArrayList<String> expected, ArrayList<Task> eventList) {
		assertEquals(expected, DataDisplay.displayEvent(eventList));

	}

	@Test
	// Display deadline list
	public void testDisplayDeadlineFunction() {
		deadlineList.add(task2);
		deadlineList.add(task1);
		ArrayList<String> expected = new ArrayList<String>();
		//expected.add("Deadline");
		expected.add("1: " + task2Print);
		expected.add("2: " + task1Print);

		testDisplayDeadline(expected, deadlineList);
	}

	private void testDisplayDeadline(ArrayList<String> expected, ArrayList<Task> deadlineList) {
		assertEquals(expected, DataDisplay.displayDeadline(deadlineList));

	}
*/
}
```
