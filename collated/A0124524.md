# A0124524
###### bin\main\resources\layouts\Search.fxml
``` fxml

<?import java.lang.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.text.*?>

<AnchorPane prefHeight="605.0" prefWidth="900.0" xmlns:fx="http://javafx.com/fxml/1" xmlns="http://javafx.com/javafx/2.2" fx:controller="main.java.gui.SearchController">
  <!-- TODO Add Nodes -->
  <children>
    <Label prefHeight="35.0" style="-fx-background-color: rgba(160, 082, 045);" text="  Search Results" textFill="WHITE" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="150.0" AnchorPane.topAnchor="0.0">
      <font>
        <Font size="25.0" fx:id="x1" />
      </font>
    </Label>
    <ListView fx:id="searchList" prefHeight="200.0" prefWidth="200.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="35.0" />
    <Label fx:id="clock" font="$x1" prefHeight="35.0" prefWidth="150.0" style="-fx-background-color: rgba(000, 000, 000);" text="" textFill="#66ffed" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" />
  </children>
</AnchorPane>
```
###### src\main\java\gui\MainApp.java
``` java
    public ObservableList<Text> getSearch() {
    	return search;
    }
    
    /**
```
###### src\main\java\gui\MainApp.java
``` java
    private void addSearch() {
    	try {
        	FXMLLoader loader = new FXMLLoader(MainApp.class.getResource(SEARCH_LAYOUT_FXML));
        	AnchorPane page = (AnchorPane) loader.load();
        	rootLayout.setTop(page);
        	
        	SearchController controller = loader.getController();
            controller.setMainApp(this);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
```
###### src\main\java\gui\MainApp.java
``` java
    private ObservableList<Text> createSearchList(ArrayList<ItemForUserScreen> itemList) {
    	search.clear();
    	for (int i = 0; i < itemList.size(); i++) {
    		if (!(itemList.get(i).getIfComplete())) {
				Text text = new Text(itemList.get(i).getPrintOnScreenMsg());
				text.setFont(Font.font ("System", 20));
				search.add(text);
			}
		}
    	return search;
    }
    
    /*
	 * testing GUI
	 * stub feedback
```
###### src\main\java\gui\SearchController.java
``` java
 */

public class SearchController {
	
	@FXML
    private ListView<Text> searchList;
	
	@FXML
    private Label clock;

	@SuppressWarnings("unused")
    private MainApp mainApp;
	
	public SearchController() {
	
	}
	
	public void setMainApp(MainApp mainApp) {
		this.mainApp = mainApp;
		
		searchList.setItems(mainApp.getSearch());
		
		DateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
	    //get current date time with Date()
	    Date date = new Date();
	    clock.setText(" " + dateFormat.format(date));
	}
}
```
###### src\main\java\logic\Search.java
``` java
        //add only top 10 urgent deadlines into list first
        ArrayList<Task> urgentDeadlines = new ArrayList<Task>();
        urgentDeadlines = obtainApproachingDeadlineTasks(TODAY, taskList);
        int counterDeadlines = 0;
        for(int i=0; i<urgentDeadlines.size(); i++) {
        	todaySummary.add(urgentDeadlines.get(i));
        	counterDeadlines++;
        	if(counterDeadlines == 10)
        		break;
        }
        //add only top 10 events into list
        ArrayList<Task> todayEvents = new ArrayList<Task>();
        todayEvents = obtainTodayEvents(TODAY, taskList);
        int counterEvents = 0;
        for(int i=0; i<todayEvents.size(); i++) {
        	todaySummary.add(todayEvents.get(i));
        	counterEvents++;
        	if(counterEvents == 10)
        		break;
        }
        //add only top 5 events into list
        int counterFloating = 0;
        for(int i=0; i<taskList.size(); i++) {
        	if(taskList.get(i).getTaskType().equals("floating") && taskList.get(i).getIsCompleted() == false) {
        		todaySummary.add(taskList.get(i));
            	counterFloating++;
        	}
        	if(counterFloating == 5)
        		break;
        }        
        return todaySummary;
    }
    
    /* Obtains 10 deadlines, 10 events and 5 floating tasks to be seen in
     * the user's next day as a summary
     * PREREQUISITE: Storage.taskList must be sorted by date and time
     */
```
###### src\main\java\logic\Search.java
``` java
    public static ArrayList<Task> obtainTomorrowSummary(Storage storage) { 
        ArrayList<Task> tmrSummary = new ArrayList<Task>();
        ArrayList<Task> taskList = storage.getTaskList();
        
        //add only top 10 urgent deadlines into list first
        ArrayList<Task> urgentDeadlines = new ArrayList<Task>();
        urgentDeadlines = obtainApproachingDeadlineTasks(TMR, taskList);
        int counterDeadlines = 0;
        for(int i=0; i<urgentDeadlines.size(); i++) {
        	tmrSummary.add(urgentDeadlines.get(i));
        	counterDeadlines++;
        	if(counterDeadlines == 10)
        		break;
        }
        //add only top 10 events into list
        ArrayList<Task> todayEvents = new ArrayList<Task>();
        todayEvents = obtainTodayEvents(TMR, taskList);
        int counterEvents = 0;
        for(int i=0; i<todayEvents.size(); i++) {
        	tmrSummary.add(todayEvents.get(i));
        	counterEvents++;
        	if(counterEvents == 10)
        		break;
        }
        //add only top 5 events into list
        int counterFloating = 0;
        for(int i=0; i<taskList.size(); i++) {
        	if(taskList.get(i).getTaskType().equals("floating") && taskList.get(i).getIsCompleted() == false) {
        		tmrSummary.add(taskList.get(i));
            	counterFloating++;
        	}
        	if(counterFloating == 5)
        		break;
        }        
        return tmrSummary;
    }
    
```
###### src\main\java\logic\Search.java
``` java
    	DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
    	String today = date.format(formatter);
    	String tmr = date.plusDays(1).format(formatter);
    	String dayAfter = date.plusDays(2).format(formatter);
    	//assumes that fullStorageTaskList is already sorted according to increasing date
    	for(int i=0; i<fullStorageTaskList.size(); i++) {
    		if(fullStorageTaskList.get(i).getTaskType().equals("deadline") && fullStorageTaskList.get(i).getIsCompleted() == false) {
        		//find all deadlines due today and add to list
        		if(fullStorageTaskList.get(i).getEndDate().equals(today))
        			urgentDeadlines.add(fullStorageTaskList.get(i));
        		//find all deadlines due tmr and add to list
        		if(fullStorageTaskList.get(i).getEndDate().equals(tmr))
        			urgentDeadlines.add(fullStorageTaskList.get(i));
        		//find all deadlines due day after and add to list
        		if(fullStorageTaskList.get(i).getEndDate().equals(dayAfter))
        			urgentDeadlines.add(fullStorageTaskList.get(i));
    		}
    	}
        return urgentDeadlines;
    }
    
    //Obtains all tasks happening on the date
```
###### src\main\java\logic\Search.java
``` java
    private static ArrayList<Task> obtainTodayEvents(LocalDateTime date, ArrayList<Task> fullStorageTaskList) {
        ArrayList<Task> eventsToday = new ArrayList<Task>();
        
    	DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
    	String today = date.format(formatter);
    	for(int i=0; i<fullStorageTaskList.size(); i++) {
    		if(fullStorageTaskList.get(i).getTaskType().equals("event") && fullStorageTaskList.get(i).getIsCompleted() == false) {
    			if(fullStorageTaskList.get(i).getStartDate().equals(today))
    				eventsToday.add(fullStorageTaskList.get(i));
    		}
    	}
    	return eventsToday;
    }
  
```
###### src\main\java\logic\Search.java
``` java
    public static ArrayList<Task> obtainRecurTaskListByItemNum(int itemNumber, ArrayList<Task> list) {
        ArrayList<Task> recurTaskGroup = new ArrayList<Task>();
        if (list.size()<itemNumber || itemNumber <= 0){
            return recurTaskGroup;
        }
        
    	Task target = list.get(itemNumber-1);
    	int recurGroupID = target.getRecurringID();
    	if (recurGroupID == 0){
    		return recurTaskGroup;
    	}
    	Storage storage = Storage.getInstance();
    	
    	for(int i=0; i<storage.getTaskList().size(); i++) {
    		if(storage.getTaskList().get(i).getRecurringID() == recurGroupID) {
    			recurTaskGroup.add(storage.getTaskList().get(i));
    		}
    	}
    	return recurTaskGroup;
    }

```
###### src\main\java\logic\SearchKeyword.java
``` java
 */

package main.java.logic;

import java.util.ArrayList;

import main.java.resources.DataDisplay;
import main.java.resources.ItemForUserScreen;
import main.java.resources.OutputToUI;
import main.java.resources.Task;
import main.java.storage.Storage;

public class SearchKeyword implements Command {
	private ArrayList<String> inputForAction = new ArrayList<String>();
	private Storage storage;
	private History history = History.getInstance();

	public SearchKeyword(ArrayList<String> userInput, Storage storage) {
		this.inputForAction = userInput;
		this.storage = storage;
	}

	@Override
	public OutputToUI execute() {
		OutputToUI outputToUI = new OutputToUI();
		int code = 0;
		ArrayList<String> printOnScreenMsgList = new ArrayList<String>();
		ArrayList<Task> taskList = new ArrayList<Task>();
		ArrayList<ItemForUserScreen> itemList = new ArrayList<ItemForUserScreen>();
		String feedbackMsg;
		String typeOfScreen = null;
		
		taskList = Search.obtainSearchResults(inputForAction.get(1).toLowerCase(), storage);
		typeOfScreen = "search";
		
		printOnScreenMsgList = DataDisplay.displayList(taskList);
		history.setScreenList(taskList);
		history.setCurrentScreen(typeOfScreen);
		history.setSearchCommand(this);
		for (int i = 0; i < taskList.size(); i++) {
			itemList.add(new ItemForUserScreen(taskList.get(i).getIsCompleted(), taskList.get(i).getTaskType(),
					printOnScreenMsgList.get(i)));
		}
		feedbackMsg = DataDisplay.feedback("Search", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		outputToUI.setItemList(itemList);
		outputToUI.setTypeOfScreen(typeOfScreen);
		return outputToUI;
	}

	@Override
	public OutputToUI undo() {
		return null;
	}

	@Override
	public OutputToUI redo() {
		return null;
	}

}
```
###### src\main\java\logic\UpdateEndTime.java
``` java
		else {
			this.oldRecurTaskGroup = Search.obtainRecurTaskListByItemNum(itemNum, screenList);
			for(int i=0; i<oldRecurTaskGroup.size(); i++) {
				this.oldTask = oldRecurTaskGroup.get(i);
				newTask = new Task (oldTask.getTaskType(), oldTask.getTaskDescription(), oldTask.getStartDate(), oldTask.getEndDate(),
						oldTask.getStartTime(), oldTask.getEndTime(), oldTask.getIsCompleted(),
						oldTask.getIsDateTimeValid(), oldTask.getRecurringID());
				newTask.setEndTime(DateAndTime.reformatTime(newEndTime));
				this.newRecurTaskGroup.add(newTask);
			}
			
		}
	}
	
```
###### src\main\java\logic\UpdateEndTime.java
``` java
		else {
			for(int i=0; i<this.newRecurTaskGroup.size(); i++) {
				storage.deleteOneItem(oldRecurTaskGroup.get(i));
				System.out.println("Outside empty");
				storage.addOneItem(newRecurTaskGroup.get(i));
			}
		}
```
###### src\main\java\logic\UpdateEndTime.java
``` java
		else {
			for(int i=0; i<this.newRecurTaskGroup.size(); i++) {
				storage.deleteOneItem(oldRecurTaskGroup.get(i));
				System.out.println("Outside empty");
				storage.addOneItem(newRecurTaskGroup.get(i));
			}
		}
```
###### src\main\java\logic\UpdateName.java
``` java
		else {
			this.oldRecurTaskGroup = Search.obtainRecurTaskListByItemNum(itemNum, screenList);
			for(int i=0; i<oldRecurTaskGroup.size(); i++) {
				this.oldTask = oldRecurTaskGroup.get(i);
				newTask = new Task (oldTask.getTaskType(), oldTask.getTaskDescription(), oldTask.getStartDate(), oldTask.getEndDate(),
						oldTask.getStartTime(), oldTask.getEndTime(), oldTask.getIsCompleted(),
						oldTask.getIsDateTimeValid(), oldTask.getRecurringID());
				newTask.setTaskDescription(newName);
				this.newRecurTaskGroup.add(newTask);
			}
		}
	}
	
```
###### src\main\java\logic\UpdateName.java
``` java
		else {
			for(int i=0; i<this.newRecurTaskGroup.size(); i++) {
				storage.deleteOneItem(oldRecurTaskGroup.get(i));
				storage.addOneItem(newRecurTaskGroup.get(i));
			}
		}
		outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Update", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		history.pushCommandToUndoList(this);
		history.clearRedoList();
		return outputToUI;
	}
	
```
###### src\main\java\logic\UpdateName.java
``` java
		else {
			for(int i=0; i<this.newRecurTaskGroup.size(); i++) {
				storage.deleteOneItem(oldRecurTaskGroup.get(i));
				storage.addOneItem(newRecurTaskGroup.get(i));
			}
		}
		outputToUI = Controller.refreshScreen();
		code = 0;
		feedbackMsg = DataDisplay.feedback("Update", code);
		outputToUI.setFeedbackMsg(feedbackMsg);
		history.pushCommandToUndoList(this);
		return outputToUI;
	}

}
```
###### src\main\java\logic\UpdateStartTime.java
``` java
		else {
			this.oldRecurTaskGroup = Search.obtainRecurTaskListByItemNum(itemNum, screenList);
			for(int i=0; i<oldRecurTaskGroup.size(); i++) {
				this.oldTask = oldRecurTaskGroup.get(i);
				newTask = new Task (oldTask.getTaskType(), oldTask.getTaskDescription(), oldTask.getStartDate(), oldTask.getEndDate(),
						oldTask.getStartTime(), oldTask.getEndTime(), oldTask.getIsCompleted(),
						oldTask.getIsDateTimeValid(), oldTask.getRecurringID());
				newTask.setStartTime(DateAndTime.reformatTime(newStartTime));
				this.newRecurTaskGroup.add(newTask);
			}
			
		}
	}
```
###### src\main\java\logic\UpdateStartTime.java
``` java
		else {
			for(int i=0; i<this.newRecurTaskGroup.size(); i++) {
				storage.deleteOneItem(oldRecurTaskGroup.get(i));
				System.out.println("Outside empty");
				storage.addOneItem(newRecurTaskGroup.get(i));
			}
		}
```
###### src\main\java\logic\UpdateStartTime.java
``` java
		else {
			for(int i=0; i<this.newRecurTaskGroup.size(); i++) {
				storage.deleteOneItem(oldRecurTaskGroup.get(i));
				System.out.println("Outside empty");
				storage.addOneItem(newRecurTaskGroup.get(i));
			}
		}
```
###### src\main\java\parser\CreateTask.java
``` java
 */

package main.java.parser;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

import main.java.resources.Task;

/*Pre-condition: 1. tasks are all incompleted
			   2. date and time given are all valid
			   3. no recurring tasks hence recurringID = 0*/

public class CreateTask {
	
	private static final String KEYWORD_BY = " by ";
	private static final int LENGTH_OF_BY = KEYWORD_BY.length();
	private static final String KEYWORD_FROM = " from ";
	private static final int LENGTH_OF_FROM = KEYWORD_FROM.length();
	private static final String KEYWORD_TO = " to ";
	private static final int LENGTH_OF_TO = KEYWORD_TO.length();
		
	public final static Task createDeadline(String taskType, String taskContent) {
		String[] dateTime;
		
		DateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
		Date today = new Date();
		
		//taskcontent must contain keyword by
		int indexToSplit = taskContent.lastIndexOf(KEYWORD_BY);
		String taskDescription = taskContent.substring(0, indexToSplit);
		taskDescription = removeSymbol(taskDescription);
		String taskDateTime = taskContent.substring(indexToSplit + (LENGTH_OF_BY));
		//taskDateTime contains both deadline date and deadline time
		if(taskDateTime.contains(";")) {
			String[] correctDateTime = new String[4];
			dateTime = taskDateTime.split(";");
				
			correctDateTime[0] = DateAndTime.reformatDate(dateTime[0]);
			correctDateTime[1] = DateAndTime.reformatTime(dateTime[1]);
			correctDateTime[2] = DateAndTime.reformatDate(dateTime[1]);
			correctDateTime[3] = DateAndTime.reformatTime(dateTime[0]);
				
			//input comes in date;time format
			if(DateAndTime.isDate(correctDateTime[0]) && (DateAndTime.isTime(correctDateTime[1]))) {
				return new Task(taskType, taskDescription, "-", correctDateTime[0], "-", correctDateTime[1], false, true, 0);
			}
			//input comes in time;date format
			else if(DateAndTime.isDate(correctDateTime[2]) && (DateAndTime.isTime(correctDateTime[3]))) {
				return new Task(taskType, taskDescription, "-", correctDateTime[2], "-", correctDateTime[3], false, true, 0);
			}
			//input format is both invalid
			else {
				return new Task(taskType, "-", "-", "-", "-", "-", false, false, 0);
			}
		}
		//taskDateTime contains only deadline date
		else if(DateAndTime.isDate(taskDateTime)) {
			String date = DateAndTime.reformatDate(taskDateTime);
			return new Task(taskType, taskDescription, "-", date, "-", "-", false, true, 0);
		}
		//taskDateTime contains only deadline time and set deadline date as today
		else if(DateAndTime.isTime(taskDateTime)) {
			String time = DateAndTime.reformatTime(taskDateTime);
			return new Task(taskType, taskDescription, "-", dateFormat.format(today), "-", time, false, true, 0);
		}
		else {
			return new Task(taskType, "-", "-", "-", "-", "-", false, false, 0);
		}
	}
	
	public final static Task createEvent(String taskType, String taskContent) {
		
		DateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
		Date today = new Date();
		
		//taskContent must contains KEYWORD_FROM and KEYWORD_TO
		int firstIndexToSplit = taskContent.lastIndexOf(KEYWORD_FROM);
		int secondIndexToSplit = taskContent.lastIndexOf(KEYWORD_TO);
		
		String taskDescription = taskContent.substring(0, firstIndexToSplit);
		String taskStart = taskContent.substring(firstIndexToSplit + (LENGTH_OF_FROM), secondIndexToSplit);
		String taskEnd = taskContent.substring(secondIndexToSplit + (LENGTH_OF_TO), taskContent.length());
			
		//taskStart and taskEnd contains both time and date
		if(taskStart.contains(";") && taskEnd.contains(";")) {
			String[] correctStartDateTime = new String[4];
			String[] startDateTime = taskStart.split(";");
			correctStartDateTime[0] = DateAndTime.reformatDate(startDateTime[0]);
			correctStartDateTime[1] = DateAndTime.reformatTime(startDateTime[1]);
			correctStartDateTime[2] = DateAndTime.reformatDate(startDateTime[1]);
			correctStartDateTime[3] = DateAndTime.reformatTime(startDateTime[0]);
				
			String[] correctEndDateTime = new String[4];
			String[] endDateTime = taskEnd.split(";");
			correctEndDateTime[0] = DateAndTime.reformatDate(endDateTime[0]);
			correctEndDateTime[1] = DateAndTime.reformatTime(endDateTime[1]);
			correctEndDateTime[2] = DateAndTime.reformatDate(endDateTime[1]);
			correctEndDateTime[3] = DateAndTime.reformatTime(endDateTime[0]);
				
			//input comes in date;time format for both start and end
			if(DateAndTime.isDate(correctStartDateTime[0]) && DateAndTime.isTime(correctStartDateTime[1]) && 
										DateAndTime.isDate(correctEndDateTime[0]) && DateAndTime.isTime(correctEndDateTime[1])) {
				return correctDateComparison(taskType, taskDescription, correctStartDateTime[0], correctEndDateTime[0], 
											correctStartDateTime[1], correctEndDateTime[1]);
				}
			//input comes in time;date format for both start and end
			else if(DateAndTime.isDate(correctStartDateTime[2]) && DateAndTime.isTime(correctStartDateTime[3]) && 
							DateAndTime.isDate(correctEndDateTime[2]) && DateAndTime.isTime(correctEndDateTime[3])) {
				return correctDateComparison(taskType, taskDescription, correctStartDateTime[2], correctEndDateTime[2], 
											correctStartDateTime[3], correctEndDateTime[3]);
				}
			//start input comes in date;time and end input comes in time;date
			else if(DateAndTime.isDate(correctStartDateTime[0]) && DateAndTime.isTime(correctStartDateTime[1]) && 
						DateAndTime.isDate(correctEndDateTime[2]) && DateAndTime.isTime(correctEndDateTime[3])) {
				return correctDateComparison(taskType, taskDescription, correctStartDateTime[0], correctEndDateTime[2], 
						correctStartDateTime[1], correctEndDateTime[3]);
				}
			//start input comes in time;date and end input comes in date;time
			else if(DateAndTime.isDate(correctStartDateTime[2]) && DateAndTime.isTime(correctStartDateTime[3]) && 
					DateAndTime.isDate(correctEndDateTime[0]) && DateAndTime.isTime(correctEndDateTime[1])) {
					return correctDateComparison(taskType, taskDescription, correctStartDateTime[2], correctEndDateTime[0], 
						correctStartDateTime[3], correctEndDateTime[1]);
			}
			else {
				return new Task(taskType, taskDescription, "-", "-", "-" , "-", false, false, 0);
			}
		}
			//taskStart and taskEnd contains only date
		else if(DateAndTime.isDate(taskStart) && DateAndTime.isDate(taskEnd)) {
			String startDate = DateAndTime.reformatDate(taskStart);
			String endDate = DateAndTime.reformatDate(taskEnd);
			taskDescription = removeSymbol(taskDescription);
		
			if(DateAndTime.compareDates(startDate, endDate)) {
				return new Task(taskType, taskDescription, startDate, endDate, "-", "-", false, true, 0);
			}
			else {
				return new Task(taskType, "-", "-", "-", "-", "-", false, false, 0);
			}
		}
		//taskStart and taskEnd contains only time
		else if(DateAndTime.isTime(taskStart) && DateAndTime.isTime(taskEnd)) {
			String startTime = DateAndTime.reformatTime(taskStart);		
			String endTime = DateAndTime.reformatTime(taskEnd);
			taskDescription = removeSymbol(taskDescription);
			//auto assume is today's event; append today 
			if(DateAndTime.compareTimes(startTime, endTime)) {
				return new Task(taskType, taskDescription, dateFormat.format(today), dateFormat.format(today), startTime, endTime, false, true, 0);
			}
			else 
				return new Task(taskType, "-", "-", "-", "-", "-", false, false, 0);
		}
		else {			
			return new Task(taskType, "-", "-", "-", "-", "-", false, false, 0);
		}
	}
	
	public final static Task createFloating(String taskType, String taskContent) {
		return new Task(taskType, removeSymbol(taskContent), "-", "-", "-", "-", false, true, 0);
	}
	
	private static Task correctDateComparison(String taskType, String taskDescription, String startDate, 
													String endDate, String startTime, String endTime) {
		taskDescription = removeSymbol(taskDescription);
		if(DateAndTime.compareDates(startDate, endDate)) {
			return new Task(taskType, taskDescription, startDate, endDate, startTime, endTime, false, true, 0);
		}
		else if(startDate.equals(endDate)  && DateAndTime.compareTimes(startTime, endTime)) {
			return new Task(taskType, taskDescription, startDate, endDate, startTime, endTime, false, true, 0);
		}
		else {
			return new Task(taskType, "-", "-", "-", "-", "-", false, false, 0);
		}
	}
	
	private static String removeSymbol(String input) {
		return input.replaceAll(";", "").replaceAll("/", "");
	}
	
```
###### src\main\java\parser\DateAndTime.java
``` java
 */

package main.java.parser;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import main.java.resources.Task;
public class DateAndTime {
	
	private static final String REGEX_WHITESPACE = " ";
	private static final String REGEX_SLASH = "/";
	private static final String REGEX_DOT = ".";
	private static final String KEYWORD_AM = "am";
	private static final String KEYWORD_PM = "pm";

	//for task creation
	public final static String reformatDate(String input) {
		
		//valid formats examples: 22 oct, 22 october, 22/10, 22.10, 22 oct 2015, 22 october 2015, 22/10/2015, 22.10.2015
		//to return date in format dd/mm/yyyy
		
		DateFormat dateFormat = new SimpleDateFormat("yyyy");
		//get current date time with Date()
		Date year = new Date();
		String currentYear = dateFormat.format(year);
		String date = "";
		boolean invalidDay = false;
		boolean invalidMonth = false;
		boolean invalidYear = false;
		boolean invalidDateFormat = false;
		
		if (isOneWord(input)) {

			//input can be dd/mm or dd/mm/yyyy; check if valid
			if (input.contains(REGEX_SLASH)) {
				ArrayList<String> dateList = new ArrayList<String>();
				String content[] = input.split(REGEX_SLASH, 2);
				dateList.add(reformatDateAndMonth(content[0])); //add date into list
				if(content[1].contains(REGEX_SLASH)) {//input is dd/mm/yyyy
					content = content[1].split(REGEX_SLASH, 2);
					dateList.add(reformatDateAndMonth(content[0])); //add month into list
					dateList.add(content[1]); //add year into list
				}
				else {
					dateList.add(reformatDateAndMonth(content[1])); //input is dd/mm
				}

				if(Integer.parseInt(dateList.get(1)) <= 12) {	//within month range
					if(isValidDD(dateList.get(0),dateList.get(1))) {//check if day is valid within the month
						date = dateList.get(0) + "/" + dateList.get(1);
					}
					else { 
						invalidDay = true;
					}
				}
				else {
					invalidMonth = true;
				}
				
				if(dateList.size() == 3) {//year is specified
					if(isValidYear(dateList.get(2))) {
						date = date + "/" + dateList.get(2);
					}
					else { 
						invalidYear = true;
					}
				}
				else { //year is not specified; append current year to it
					date = date + "/" + currentYear;
				}	
			}
			//format is in dd.mm.yyyy or dd.mm
			else if (input.contains(REGEX_DOT)) {
				ArrayList<String> dateList = new ArrayList<String>();
				String content[] = input.split("\\.", 2);
				dateList.add(reformatDateAndMonth(content[0])); //add date into list
				if(content[1].contains(REGEX_DOT)) {//input is dd.mm.yyyy
					content = content[1].split("\\.", 2);
					dateList.add(reformatDateAndMonth(content[0])); //add month into list
					dateList.add(content[1]); //add year into list
				}
				else {
					dateList.add(reformatDateAndMonth(content[1])); //input is dd.mm
				}
				if(Integer.parseInt(dateList.get(1)) <= 12) { 	//within month range
					if(isValidDD(dateList.get(0),dateList.get(1))) { //check if day is valid within the month
						date = dateList.get(0) + "/" + dateList.get(1);
					}
					else {
						invalidDay = true;
					}
				}
				else {
					invalidMonth = true;
				}
				
				if(dateList.size() == 3) {//year is specified
					if(isValidYear(dateList.get(2))) {
						date = date + "/" + dateList.get(2);
					}
					else { 
						invalidYear = true;
					}
				}
				else { //year is not specified; append current year to it
					date = date + "/" + currentYear;
				}	
			}
			else {
				invalidDateFormat = true;
			}
		}
		else {
			//input is in eg (22 october/ 22 oct)
			ArrayList<String> dateList = new ArrayList<String>();
			String content[] = input.split(REGEX_WHITESPACE, 2);
			dateList.add(reformatDateAndMonth(content[0])); //add date into list
			if(content[1].contains(REGEX_WHITESPACE)) {//input is dd month yyyy
				content = content[1].split(REGEX_WHITESPACE, 2);
				dateList.add(content[0].toLowerCase()); //add month into list
				dateList.add(content[1]); //add year into list
			}
			else {
				dateList.add(content[1].toLowerCase()); //input is dd month 
			}
			
			switch(dateList.get(1)) {
			//january
			case "jan":
			case "january":
				if(isValidDD(dateList.get(0), dateList.get(1))) {
					date = dateList.get(0) + "/01/";
					if(dateList.size() == 3) {//year is specified
						if(isValidYear(dateList.get(2))) {
							date = date  + dateList.get(2);
						}
						else { 
							invalidYear = true;
						}
					}
					else { //year is not specified; append current year to it
						date = date + currentYear;
					}	
				}
				else {
					date = "invalid day";
				}
				break;
			//february
			case "feb":
			case "february":
				if(isValidDD(dateList.get(0), dateList.get(1))) {
					date = dateList.get(0) + "/02/";
					if(dateList.size() == 3) {//year is specified
						if(isValidYear(dateList.get(2))) {
							date = date  + dateList.get(2);
						}
						else { 
							invalidYear = true;
						}
					}
					else { //year is not specified; append current year to it
						date = date + currentYear;
					}	
				}
				else {
					date = "invalid day";
				}
				break;
			//march
			case "mar":
			case "march":
				if(isValidDD(dateList.get(0), dateList.get(1))) {
					date = dateList.get(0) + "/03/";
					if(dateList.size() == 3) {//year is specified
						if(isValidYear(dateList.get(2))) {
							date = date  + dateList.get(2);
						}
						else { 
							invalidYear = true;
						}
					}
					else { //year is not specified; append current year to it
						date = date + currentYear;
					}	
				}
				else {
					date = "invalid day";
				}
				break;	
			//april
			case "apr":
			case "april":
				if(isValidDD(dateList.get(0), dateList.get(1))) {
					date = dateList.get(0) + "/04/";
					if(dateList.size() == 3) {//year is specified
						if(isValidYear(dateList.get(2))) {
							date = date + dateList.get(2);
						}
						else { 
							invalidYear = true;
						}
					}
					else { //year is not specified; append current year to it
						date = date + currentYear;
					}	
				}
				else {
					date = "invalid day";
				}
				break;
			//may
			case "may":
				if(isValidDD(dateList.get(0), dateList.get(1))) {
					date = dateList.get(0) + "/05/";
					if(dateList.size() == 3) {//year is specified
						if(isValidYear(dateList.get(2))) {
							date = date  + dateList.get(2);
						}
						else { 
							invalidYear = true;
						}
					}
					else { //year is not specified; append current year to it
						date = date + currentYear;
					}	
				}
				else {
					date = "invalid day";
				}
				break;
			//june
			case "jun":
			case "june":
				if(isValidDD(dateList.get(0), dateList.get(1))) {
					date = dateList.get(0) + "/06/";
					if(dateList.size() == 3) {//year is specified
						if(isValidYear(dateList.get(2))) {
							date = date  + dateList.get(2);
						}
						else { 
							invalidYear = true;
						}
					}
					else { //year is not specified; append current year to it
						date = date + currentYear;
					}	
				}
				else {
					date = "invalid day";
				}
				break;
			//july
			case "jul":
			case "july":
				if(isValidDD(dateList.get(0), dateList.get(1))) {
					date = dateList.get(0) + "/07/";
					if(dateList.size() == 3) {//year is specified
						if(isValidYear(dateList.get(2))) {
							date = date  + dateList.get(2);
						}
						else {
							invalidYear = true;
						}
					}
					else { //year is not specified; append current year to it
						date = date + currentYear;
					}	
				}
				else {
					date = "invalid day";
				}
				break;
			//august
			case "aug":
			case "august":
				if(isValidDD(dateList.get(0), dateList.get(1))) {
					date = dateList.get(0) + "/08/";
					if(dateList.size() == 3) {//year is specified
						if(isValidYear(dateList.get(2))) {
							date = date + dateList.get(2);
						}
						else { 
							invalidYear = true; 
						}
					}
					else { //year is not specified; append current year to it
						date = date + currentYear;
					}	
				}
				else {
					date = "invalid day";
				}
				break;
			//september
			case "sept":
			case "september":
				if(isValidDD(dateList.get(0), dateList.get(1))) {
					date = dateList.get(0) + "/09/";
					if(dateList.size() == 3) {//year is specified
						if(isValidYear(dateList.get(2))) {
							date = date + dateList.get(2);
						}
						else {
							invalidYear = true;
						}
					}
					else { //year is not specified; append current year to it
						date = date + currentYear;
					}	
				}
				else {
					date = "invalid day";
				}
				break;
			//october
			case "oct":
			case "october":
				if(isValidDD(dateList.get(0), dateList.get(1))) {
					date = dateList.get(0) + "/10/";
					if(dateList.size() == 3) {//year is specified
						if(isValidYear(dateList.get(2))) {
							date = date + dateList.get(2);
						}
						else { 
							invalidYear = true;
						}
					}
					else { //year is not specified; append current year to it
						date = date + currentYear;
					}	
				}
				else {
					date = "invalid day";
				}
				break;
			//november
			case "nov":
			case "november":
				if(isValidDD(dateList.get(0), dateList.get(1))) {
					date = dateList.get(0) + "/11/";
					if(dateList.size() == 3) {//year is specified
						if(isValidYear(dateList.get(2))) {
							date = date + dateList.get(2);
						}
						else { 
							invalidYear = true;
						}
					}
					else { //year is not specified; append current year to it
						date = date + currentYear;
					}	
				}
				else {
					date = "invalid day";
				}
				break;
			//december
			case "dec":
			case "december":
				if(isValidDD(dateList.get(0), dateList.get(1))) {
					date = dateList.get(0) + "/12/";
					if(dateList.size() == 3) {//year is specified
						if(isValidYear(dateList.get(2))) {
							date = date + dateList.get(2);
						}
						else { 
							invalidYear = true;
						}
					}
					else { //year is not specified; append current year to it
						date = date + currentYear;
					}	
				}
				else {
					date = "invalid day";
				}
				break;	
			default:
				date = "invalid month";
				break;
			}
		}
		if (!invalidDay && !invalidMonth && !invalidYear && !invalidDateFormat) {
			return date;
		}
		else if(invalidDay) {
			return "invalid day";
		}
		else if(invalidMonth) {
			return "invalid month";
		}
		else if(invalidYear) {
			return "invalid year";
		}
		else {
			return "invalid date format";
		}
	}
	
	//for task creation
	public final static String reformatTime(String input) {
		
		//valid formats: 9am, 901am, 0901am, 9:01am, 9pm, 0901
		//to return in 24-hour format: 0901
		String time = "";
		
		//to remove cases of 9:01am etc
		input = input.toLowerCase();
		if(input.contains(":")) {
			input = input.replaceAll(":", "");
		}
		if(isValid12Format(input)) {
			if(input.contains(KEYWORD_AM)) {
				time = input.substring(0, input.indexOf(KEYWORD_AM));
				//eg. 901am, 801am
				if(time.length() == 3) {
					time = "0" + time;
				}
				//eg. 12am, 11am, 09am 
				if(time.length() == 2) {
					time = time + "00";
				}
				//eg. 9am, 8am
				if(time.length() == 1) {
					time = "0" + time + "00";
				}
				//special case: to change 12am to 0000, eg 1201am -> 0001
				if((time.indexOf("1") == 0) && (time.indexOf("2") == 1)) { 
					time = time.replaceFirst("12", "00");		
				}
			}
			else if(input.contains(KEYWORD_PM)) {
				time = input.substring(0, input.indexOf(KEYWORD_PM));
				if(time.length() == 3) {
					time = "0" + time;
				}
				//eg. 12am, 11am, 09am 
				if(time.length() == 2) {
					time = time + "00";
				}
				//eg. 9am, 8am
				if(time.length() == 1) {
					time = "0" + time + "00";
				}
				int timeNumeric = Integer.parseInt(time) + 1200;
				time = String.valueOf(timeNumeric);
			}
			else {
				return "invalid time format";
			}
		}
		else if(isValid24Format(input)) {
			time = input;
		}
		else {
			return "invalid time format"; 
		}
		
		if (time.equals("")) {
			return "invalid time format";
		}
		else { 
			return time; 
		}
	}
	
	//for task creation
	public final static boolean isDate(String input) {
		if((reformatDate(input).contains("invalid"))) {
			return false;
		}
		else { 
			return true;
		}
	}
	
	//for task creation
	public final static boolean isTime(String input) {
		if((reformatTime(input).contains("invalid"))) {
			return false;
		}
		else { 
			return true;
		}
	}
	
	//for task creation
	//compare dates; return true only if dateA is earlier than or equal to dateB
	//only for date formats: dd/mm/yyyy
	public final static boolean compareDates(String dateA, String dateB) {
		String[] contentA = dateA.split("/", 3); 
		String[] contentB = dateB.split("/", 3);
		
		//check if dateA is in dd/mm/yyyy format
		if (!dateA.matches("([0-9]{2})/([0-9]{2})/([0-9]{4})")) {
			return false;
		}
		else if(!dateB.matches("([0-9]{2})/([0-9]{2})/([0-9]{4})")) {
			return false;
		}
		//compare year first
		else  {
			if (Integer.parseInt(contentA[2]) > Integer.parseInt(contentB[2])) {
				return false;
			}
			else if (Integer.parseInt(contentA[2]) < Integer.parseInt(contentB[2])) {
				return true;
			}
			//year is same
			else {
				//compare month
				if (Integer.parseInt(contentA[1]) > Integer.parseInt(contentB[1])) {
					return false;
				}
				else if (Integer.parseInt(contentA[1]) < Integer.parseInt(contentB[1])) {
					return true;
				}
				//month is same
				else {
					if (Integer.parseInt(contentA[0]) > Integer.parseInt(contentB[0])) {
						return false;
					}
					else if (Integer.parseInt(contentA[0]) < Integer.parseInt(contentB[0])) {
						return true;
					}
					//day is same
					else { 
						return true;
					}
				}
			}
		}
	}
	
	//for task creation
	//compare time; return true only if timeA is earlier than or equal to timeB
	//only for 24-hour time format
	public final static boolean compareTimes(String timeA, String timeB) {
		if(!isValid24Format(timeA)) {
			return false;
		}
		else if(!isValid24Format(timeB)) {
			return false;
		}
		else { 
			return (Integer.parseInt(timeA) <= Integer.parseInt(timeB));
		}
	}
	//for logic updating checking
	public final static boolean isValidUpdateET(Task event, String newET) {
		//if same date; ST must be earlier than or equal to newET
		if(event.getEndDate().equals(event.getStartDate())) {
			if(compareTimes(event.getStartTime(), newET)) {
				return true;
			}
			else {
				return false;
			}
		}
		//if different dates(ED is later than SD), ET can be any time
		else 
			return true;
	}
	
	//for logic updating checking
	public final static boolean isValidUpdateST(Task event, String newST) {
		//if same date; newST must be earlier than or equal to ET
		if(event.getEndDate().equals(event.getStartDate())) {
			if(compareTimes(newST, event.getEndTime())) {
				return true;
			}
			else {
				return false;
			}
		}
		//if different dates(ED is later than SD), ET can be any time
		else {
			return true;
		}
	}
	
	private static boolean isValid12Format(String time) {
		time = time.toLowerCase();
		//remove cases of time with 9:30am, 10:30pm
		if(time.contains(":")) {
			time = time.replaceAll(":", "");
		}
		if(time.contains(KEYWORD_AM)) { 
			time = time.substring(0, time.indexOf(KEYWORD_AM));
		}
		else if(time.contains(KEYWORD_PM)) {
			time = time.substring(0, time.indexOf(KEYWORD_PM));
		}
		else { 
			return false;
		}
		//for cases: 930am, 1020am
		if (onlyDigits(time)) {
			//pure hour; eg 9am, 10am
			if(Integer.parseInt(time) <= 12 && Integer.parseInt(time) > 0) {
				return true;
			}
			//contains  single digit hours and min; max 959am, 959pm, min 000am,000pm
			else if (time.length() == 3) {
				int count = 0;
				//check last char; can only be digit 0 to 9
				if(Character.isDigit(time.charAt(2))) {
					count++;
				}
				//check second char; can only be digit 0 to 5
				if(Character.isDigit(time.charAt(1))) {
					if(Character.getNumericValue(time.charAt(2)) <= 5) {
							count++;
					}
				}
				//check first char; can be digit 0 to 9
				if(Character.isDigit(time.charAt(0))) {
					count++;
				}
				return (count == 3);				
			}
			//contains  double digit hours and min; eg 0930am, 1259am
			else if (time.length() == 4) {
				int count = 0;
				//check last char; can only be digit 0 to 9
				if(Character.isDigit(time.charAt(3))) {
					count++;
				}
				//check third char; can only be digit 0 to 5
				if(Character.isDigit(time.charAt(2))) {
					if(Character.getNumericValue(time.charAt(2)) <= 5) {
							count++;
					}
				}
				//check second char; can be digit 0 to 9
				if(Character.isDigit(time.charAt(1))) {
					count++;
				}
				//check first char; can only be digit 0 to 1
				//if digit is 1; second char can only be 0, 1 or 2
				if(Character.isDigit(time.charAt(0))) {
					if(Character.getNumericValue(time.charAt(0)) == 0) {
							count++;
					}
					else if(Character.getNumericValue(time.charAt(0)) == 1) {
						if(Character.getNumericValue(time.charAt(1)) <= 2) {
							count++;
						}
					}
				}	
				return (count == 4);
			}
			else {
				return false;
			}
		}
		else {
			return false;
		}
	}
	private static boolean isValid24Format(String time) {
		int count = 0;
		
		if(time.length() != 4) {
			return false;
		}
		//check last char; can only be digit 0 to 9
		if(Character.isDigit(time.charAt(3))) {
			count++;
		}
		//check third char; can only be digit 0 to 5
		if(Character.isDigit(time.charAt(2))) {
			if(Character.getNumericValue(time.charAt(2)) <= 5) {
					count++;
			}
		}
		//check second char; can be digit 0 to 9
		if(Character.isDigit(time.charAt(1))) {
			count++;
		}
		//check first char; can only be digit 0 to 2
		//if digit is 2, second digit can only in range of 0 <= x <= 3
		if(Character.isDigit(time.charAt(0))) {
			if(Character.getNumericValue(time.charAt(0)) <= 1) {
					count++;
			}
			else if(Character.getNumericValue(time.charAt(0)) == 2) {
				if(Character.getNumericValue(time.charAt(1)) <= 3) {
					count++;
				}
			}
		}
		return (count == 4);
	}
	
	private static boolean isValidDD(String dd, String mm) {
		
		int day = Integer.parseInt(dd);
		boolean valid = false;
		
		switch(mm.toLowerCase()) {
		//january
		case "jan":
		case "january":
		case "01":
		case "1":
		//march
		case "mar":
		case "march":
		case "03":
		case "3":
		//may
		case "may":
		case "05":
		case "5":
		//july
		case "jul":
		case "july":
		case "07":
		case "7":
		//august
		case "aug":
		case "august":
		case "08":
		case "8":
		//october
		case "oct":
		case "october":
		case "10":
		//december
		case "dec":
		case "december":
		case "12":
			if (day <= 31)
				valid = true;
			break;
		//february
		case "feb":
		case "february":
		case "02":
		case "2":
			if (day <= 29)
				valid = true;
			break;
		//april
		case "apr":
		case "april":
		case "04":
		case "4":
		//june
		case "jun":
		case "june":
		case "06":
		case "6":
		//september
		case "sept":
		case "september":
		case "09":
		case "9":
		//november
		case "nov":
		case "november":
		case "11":
			if (day <= 30)
				valid = true;
			break;
		default:
			break;
		}
		return valid;
	}
	private static String reformatDateAndMonth(String input) {
		switch (input) {
		case "1":
			return "01";
		case "2":
			return "02";
		case "3":
			return "03";
		case "4":
			return "04";
		case "5":
			return "05";
		case "6":
			return "06";
		case "7":
			return "07";
		case "8":
			return "08";
		case "9":
			return "09";
		default:
			return input;
		}
	}
	//check if a string input is a valid year; cannot be past year
	private static boolean isValidYear(String input) {
		DateFormat dateFormat = new SimpleDateFormat("yyyy");
		Date date = new Date();
		
		return (onlyDigits(input) && (input.length() == 4) && (Integer.parseInt(input) >= Integer.parseInt(dateFormat.format(date)))); 
	}
	//check if a string input is only a word
	private final static boolean isOneWord(String input) {
		if (input.contains(REGEX_WHITESPACE)) {
			return false;
		}
		else { 
			return true;
		}
	}
	//check if a string input are all digits only
	private final static boolean onlyDigits(String input) {
		int count = 0;
		
		for(int i=0; i<input.length(); i++) {
			if(Character.isDigit(input.charAt(i))) {
				count++;
			}
		}
		return (count == input.length());
	}
	
```
###### src\main\java\parser\DateAndTimeTest.java
``` java
 */

package main.java.parser;

import static org.junit.Assert.*;

import org.junit.Test;

public class DateAndTimeTest {

	@Test
	public void testReformatDate() {
		//invalid date format 
		assertEquals("wrong date format", "invalid date format", DateAndTime.reformatDate("abcdef"));
		assertEquals("wrong date format", "invalid date format", DateAndTime.reformatDate("22,12,2015"));
		
		//test date formats dd/mm, dd/mm/yyyy
		//check month first, then date then year
		
		//test correct date, month and year
		assertEquals("correct date, month and year", "22/10/2015", DateAndTime.reformatDate("22/10/2015"));
		
		// valid date and month, year not specified
		assertEquals("current year will be appended", "22/10/2015", DateAndTime.reformatDate("22/10"));
		
		//invalid month but valid date
		assertEquals("prints invalid month", "invalid month", DateAndTime.reformatDate("22/13"));
		
		//invalid date but valid month
		assertEquals("prints invalid day", "invalid day", DateAndTime.reformatDate("32/10"));
		
		//invalid date and invalid month
		assertEquals("looks at month first", "invalid month", DateAndTime.reformatDate("32/13"));
		
		//invalid year but valid day and month
		assertEquals("2014 is before current year so not treated as a valid year", "invalid year", DateAndTime.reformatDate("22/12/2014"));
		
		//test date formats dd.mm, dd.mm.yyyy
		//reformatDate will change to expected date format: dd/mm/yyyy
		//check month first, then date then year
				
		//test correct date, month and year
		assertEquals("correct date, month and year", "22/10/2015", DateAndTime.reformatDate("22.10.2015"));
				
		// valid date and month, year not specified
		assertEquals("current year will be appended", "22/10/2015", DateAndTime.reformatDate("22.10"));
				
		//invalid month but valid date
		assertEquals("prints invalid month", "invalid month", DateAndTime.reformatDate("22.13"));
				
		//invalid date but valid month
		assertEquals("prints invalid day", "invalid day", DateAndTime.reformatDate("32.10"));
				
		//invalid date and invalid month
		assertEquals("looks at month first", "invalid month", DateAndTime.reformatDate("32.13"));
				
		//invalid year but valid day and month
		assertEquals("2014 is before current year so not treated as a valid year", "invalid year", DateAndTime.reformatDate("22.10.2014"));
		
		//test formats: dd month yyyy, dd month, month can be full word or short form
		//testing a valid month and valid date without specified year
		//month is a full word
		assertEquals("prints in dd/mm/yyyy format", "22/10/2015", DateAndTime.reformatDate("22 october"));
		
		//month is short form
		assertEquals("prints in dd/mm/yyyy format", "22/10/2015", DateAndTime.reformatDate("22 oct"));
		
		//case is ignored, method shld read the month regardless of case
		assertEquals("prints in dd/mm/yyyy format", "22/10/2015", DateAndTime.reformatDate("22 oCtoBEr"));
		
		//append the specified year
		assertEquals("appends the specified year: 2016", "22/10/2016", DateAndTime.reformatDate("22 oct 2016"));
		
		//month that is spelled wrongly & a month that is not valid
		assertEquals("month spelled wrongly will not be processed", "invalid month", DateAndTime.reformatDate("22 octobre"));
		assertEquals("month that is not valid will not be processed", "invalid month", DateAndTime.reformatDate("22 abcdef"));
		
		//invalid day of the month will not be processed
		assertEquals("invalid day will be printed", "invalid day", DateAndTime.reformatDate("32 oct"));
	}
	
	@Test
	public void testReformatTime() {
		//unaccepted time formats will not be processed
		assertEquals("wrong time format", "invalid time format", DateAndTime.reformatTime("abcdef"));
		assertEquals("wrong time format", "invalid time format", DateAndTime.reformatTime("11om"));
		assertEquals("wrong time format", "invalid time format", DateAndTime.reformatTime("9999"));
		assertEquals("wrong time format", "invalid time format", DateAndTime.reformatTime("001"));
		assertEquals("wrong time format", "invalid time format", DateAndTime.reformatTime("10"));
		assertEquals("wrong time format", "invalid time format", DateAndTime.reformatTime("23564"));
		
		//tested format: time am, time pm
		//returns in 24 hour format
		assertEquals("pure hour am", "0900", DateAndTime.reformatTime("9am"));
		assertEquals("pure hour pm", "2100", DateAndTime.reformatTime("9pm"));
		assertEquals("minutes will be added in", "0932", DateAndTime.reformatTime("932am"));
		//invalid minutes will not be processed
		assertEquals("minutes should be max of 59", "invalid time format", DateAndTime.reformatTime("999am"));
		//invalid hour will not be processed
		assertEquals("hours should be max of 12", "invalid time format", DateAndTime.reformatTime("1358am"));
		//hours can only be in a range from 1 to 12
		assertEquals("0am is invalid", "invalid time format", DateAndTime.reformatTime("0am"));
		//formats can include ":" to separate mins and hours
		assertEquals("semi-colon can be used to separate", "0900", DateAndTime.reformatTime("9:00am"));
		
		//tested format: 24 hour format
		assertEquals("valid time format", "0000", DateAndTime.reformatTime("0000"));
		assertEquals("valid time format", "1323", DateAndTime.reformatTime("1323"));
		assertEquals("valid time format", "2359", DateAndTime.reformatTime("2359"));
		//24 hour format is only from 0000 to 2359
		assertEquals("over time range", "invalid time format", DateAndTime.reformatTime("2459"));
		assertEquals("over time format", "invalid time format", DateAndTime.reformatTime("12359"));
		assertEquals("under time format", "invalid time format", DateAndTime.reformatTime("000"));
	}
	
	@Test
	//compares only valid dates and date format can only be dd/mm/yyyy
	public void testCompareDates() {
		//return false compared dates is not in dd/mm/yyyy format
		assertFalse(DateAndTime.compareDates("22 oct", "23 oct"));
		//first date must be earlier than second date
		//compare year first
		assertTrue(DateAndTime.compareDates("22/10/2015", "22/10/2016"));
		assertFalse(DateAndTime.compareDates("22/10/2016", "22/10/2015"));
		
		//if year is the same, compare months
		assertTrue(DateAndTime.compareDates("22/10/2015", "22/11/2015"));
		assertFalse(DateAndTime.compareDates("22/11/2015", "22/10/2015"));
		
		//if month is also same, compare days
		assertTrue(DateAndTime.compareDates("21/10/2015", "22/10/2015"));
		assertFalse(DateAndTime.compareDates("22/10/2015", "21/10/2015"));
		//same dates will return true
		assertTrue(DateAndTime.compareDates("22/10/2015", "22/10/2015"));
	}
	
	@Test
	//compares only valid time and time format is only for 24 hour
	public void testCompareTimes() {
		//return false if not in 24 hour format
		assertFalse(DateAndTime.compareTimes("9am", "10am"));
		assertFalse(DateAndTime.compareTimes("2400", "000"));
		
		//first time must be earlier than second time
		//same time will return true
		assertTrue(DateAndTime.compareTimes("0000", "2359"));
		assertFalse(DateAndTime.compareTimes("2359", "0000"));
		assertTrue(DateAndTime.compareTimes("0000", "0000"));
	}
}
```
###### src\main\java\parser\FlexiCommands.java
``` java
 */

package main.java.parser;

public class FlexiCommands {
	
	public static String flexiCommands(String command) {
		switch(command) {
			//create task commands
			case "add":
			case "a":
			case "create":
			case "c":
				return "add";
			//delete task commands
			case "delete":
			case "del":
			case "d":
				return "delete";
			//update task commands
			case "update":
			case "u":
			case "edit":
			case "e":
				return "update";
			//new update functions
			case "-n":
				return "-n";
			case "-sd":
				return "-sd";
			case "-st":
				return "-st";
			case "-ed":
				return "-ed";
			case "-et":
				return "-et";
			//display task commands
			case "display":
			case "view":
			case "v":
				return "display";
			// exit command
			case "exit":
			case "quit":
				return "exit";
			//help command
			case "help":
				return "help";
			//undo command
			case "undo":
				return "undo";
			// redo command
			case "redo":
				return "redo";
			//complete command
			case "complete":
			case "completed":
			case "done":
			case "finished":
			case "finish":
				return "complete";
			//search command
			case "search":
			case "s":
			case "find":
			case "f":
				return "search";
			//recurring task
			case "recurring":
			case "recur":
			case "r":
				return "recurring";
			case "incompleted":
			case "incomplete":
				return "incomplete";
			case "set":
				return "set";
			default:
				return command;	
		}
	}
	
	public static String flexiDisplayCommands(String command){
		
		switch (command.toLowerCase()) {
		case "floating":
			command = "floating";
			break;
		case "event":
			command = "event";
			break;
		case "deadline":
			command = "deadline";
			break;
		case "unfinished":
		case "incompleted":
		case "incomplete":
			command = "incomplete";
			break;
		case "complete":
		case "completed":
		case "done":
		case "finish":
		case "finished":
			command = "complete";
			break;
		case "today":
			command = "today";
			break;
		case "tomorrow":
		case "tmr":
		case "tml":
			command = "tomorrow";
			break;
		case "all":
			command = "all";
			break;
		/**
```
###### src\main\java\parser\FlexiCommands.java
``` java
		default:
			break;
		}
		return command;
	}
}
```
###### src\main\java\parser\FlexiCommandsTest.java
``` java
 */

package main.java.parser;

import static org.junit.Assert.*;

import org.junit.Test;

public class FlexiCommandsTest {

	@Test
	public void testFlexiCommands() {
		//flexi commands for adding a task
		assertTrue(FlexiCommands.flexiCommands("add").equals("add"));
		assertTrue(FlexiCommands.flexiCommands("a").equals("add"));
		assertTrue(FlexiCommands.flexiCommands("create").equals("add"));
		assertTrue(FlexiCommands.flexiCommands("c").equals("add"));
		assertFalse(FlexiCommands.flexiCommands("addddddd").equals("add"));
		//delete task commands
		assertTrue(FlexiCommands.flexiCommands("delete").equals("delete"));
		assertTrue(FlexiCommands.flexiCommands("del").equals("delete"));
		assertTrue(FlexiCommands.flexiCommands("d").equals("delete"));
		assertFalse(FlexiCommands.flexiCommands("ddddddd").equals("delete"));
		//update task commands
		assertTrue(FlexiCommands.flexiCommands("-n").equals("-n"));
		assertFalse(FlexiCommands.flexiCommands("-nn").equals("-n"));
		
		assertTrue(FlexiCommands.flexiCommands("-sd").equals("-sd"));
		assertFalse(FlexiCommands.flexiCommands("sd").equals("-sd"));
		
		assertTrue(FlexiCommands.flexiCommands("-ed").equals("-ed"));
		assertFalse(FlexiCommands.flexiCommands("-e").equals("-ed"));
		
		assertTrue(FlexiCommands.flexiCommands("-st").equals("-st"));
		assertFalse(FlexiCommands.flexiCommands("-stt").equals("-st"));
		
		assertTrue(FlexiCommands.flexiCommands("-et").equals("-et"));
		assertFalse(FlexiCommands.flexiCommands("etttt").equals("-et"));
		//display task commands
		assertTrue(FlexiCommands.flexiCommands("display").equals("display"));
		assertTrue(FlexiCommands.flexiCommands("view").equals("display"));
		assertFalse(FlexiCommands.flexiCommands("vvv").equals("display"));
		// exit command
		assertTrue(FlexiCommands.flexiCommands("exit").equals("exit"));
		assertTrue(FlexiCommands.flexiCommands("quit").equals("exit"));
		//help command
		assertFalse(FlexiCommands.flexiCommands("help help").equals("help"));
		//undo command
		// redo command
		assertTrue(FlexiCommands.flexiCommands("redo").equals("redo"));
		assertTrue(FlexiCommands.flexiCommands("undo").equals("undo"));
		//complete command
		assertTrue(FlexiCommands.flexiCommands("complete").equals("complete"));
		assertTrue(FlexiCommands.flexiCommands("completed").equals("complete"));
		assertTrue(FlexiCommands.flexiCommands("done").equals("complete"));
		assertTrue(FlexiCommands.flexiCommands("finished").equals("complete"));
		assertTrue(FlexiCommands.flexiCommands("finish").equals("complete"));
		assertTrue(FlexiCommands.flexiCommands("incomplete").equals("incomplete"));
		assertTrue(FlexiCommands.flexiCommands("incompleted").equals("incomplete"));
		//search command
		assertTrue(FlexiCommands.flexiCommands("search").equals("search"));
		assertTrue(FlexiCommands.flexiCommands("find").equals("search"));
		assertTrue(FlexiCommands.flexiCommands("s").equals("search"));
		assertTrue(FlexiCommands.flexiCommands("f").equals("search"));
		//recurring task
		assertTrue(FlexiCommands.flexiCommands("recurring").equals("recurring"));
		assertTrue(FlexiCommands.flexiCommands("recur").equals("recurring"));
		assertTrue(FlexiCommands.flexiCommands("r").equals("recurring"));

		assertTrue(FlexiCommands.flexiCommands("set").equals("set"));
		
		//invalid cases
		assertTrue(FlexiCommands.flexiCommands("hahaha").equals("invalid command"));
		assertFalse(FlexiCommands.flexiCommands("abcdefg add adwd").equals("add"));
	}

	@Test
	public void testFlexiDisplayCommands() {
		//tasks: deadline event floating
		assertTrue(FlexiCommands.flexiDisplayCommands("deadline").equals("deadline"));
		assertTrue(FlexiCommands.flexiDisplayCommands("event").equals("event"));
		assertTrue(FlexiCommands.flexiDisplayCommands("floating").equals("floating"));
		
		//complete incomplete
		assertTrue(FlexiCommands.flexiDisplayCommands("completed").equals("complete"));
		assertTrue(FlexiCommands.flexiDisplayCommands("complete").equals("complete"));
		assertTrue(FlexiCommands.flexiDisplayCommands("finished").equals("complete"));
		assertTrue(FlexiCommands.flexiDisplayCommands("done").equals("complete"));
		
		assertTrue(FlexiCommands.flexiDisplayCommands("incomplete").equals("incomplete"));
		assertTrue(FlexiCommands.flexiDisplayCommands("incompleted").equals("incomplete"));

		//today tomorrow all
		assertTrue(FlexiCommands.flexiDisplayCommands("today").equals("today"));
		
		assertTrue(FlexiCommands.flexiDisplayCommands("tomorrow").equals("tomorrow"));
		assertTrue(FlexiCommands.flexiDisplayCommands("tmr").equals("tomorrow"));
		assertTrue(FlexiCommands.flexiDisplayCommands("tml").equals("tomorrow"));
		
		assertTrue(FlexiCommands.flexiDisplayCommands("all").equals("all"));
	}

}
```
###### src\main\java\parser\Parser.java
``` java
 */

package main.java.parser;

import java.util.ArrayList;

import main.java.resources.Task;

public class Parser {
	
	private static final String REGEX_WHITESPACE = " ";
	private static final String KEYWORD_BY = " by ";
	private static final String KEYWORD_FROM = " from ";
	private static final String KEYWORD_TO = " to ";
	
	//FOR LOGIC USE ONLY
	public final static ArrayList<String> retrieveCommand(String inputFromLogic){
		
		ArrayList<String> contentListForLogic = new ArrayList<String>();
		inputFromLogic = formatInputForValidParsing(inputFromLogic);
		updateList(inputFromLogic, contentListForLogic);
		
		return contentListForLogic;
	}
	
	//FOR LOGIC USE ONLY
	public final static Task createTaskForAdd(ArrayList<String> listFromLogic) {
			
			Task task = new Task();
			String taskType = identifyTaskType(listFromLogic);
			String taskContent = listFromLogic.get(1);
			
			switch(taskType) {
			case "deadline":
				task = CreateTask.createDeadline(taskType, taskContent);
				break;
			case "event":
				task = CreateTask.createEvent(taskType, taskContent);
				break;
			case "floating":
				task = CreateTask.createFloating(taskType, taskContent);
				break;
			default:
				break;
			}
			return task;
		}
	
	//FOR LOGIC USE ONLY
	public final static ArrayList<Task> createRecurringTasks(ArrayList<String> listFromLogic) {
		ArrayList<Task> recurringTasks = new ArrayList<Task>();
		recurringTasks = RecurringTask.create(listFromLogic);

		return recurringTasks;
	}
	
	//FOR LOGIC USE ONLY
	//formats the display commands with flexicommands
	public final static ArrayList<String> flexiDisplay(ArrayList<String> listFromLogic) {
		String displayContent = listFromLogic.remove(1);
		displayContent = FlexiCommands.flexiDisplayCommands(displayContent);
		listFromLogic.add(displayContent);
		
		return listFromLogic;
	}
	
	private static void updateList(String inputFromLogic, ArrayList<String> contentListForLogic) {
		
		//for commands: exit, help, undo etc
		if(isOneWord(inputFromLogic)) {
			contentListForLogic.add(FlexiCommands.flexiCommands(inputFromLogic));
		}
		
		else {  
			//splitting first input from logic into 2: (command) (content)
			String content[] = inputFromLogic.split(REGEX_WHITESPACE, 2);
			contentListForLogic.add(FlexiCommands.flexiCommands(content[0]));
			contentListForLogic.add(content[1]);
		}
	}
	public static String identifyTaskType(ArrayList<String> listFromLogic ) {
		String taskContent = listFromLogic.get(1);
		
		if(taskContent.contains(KEYWORD_BY)) {
			return "deadline";
		}
		else if(taskContent.contains(KEYWORD_FROM) && taskContent.contains(KEYWORD_TO)) {
			return "event";
		}
		else {
			return "floating";
		}
	}
	
	//removes all unnecessary whitespaces to 1 whitespace
	private final static String formatInputForValidParsing (String input) {
		return input.replaceAll("\\s+", REGEX_WHITESPACE).trim();
	}
	//check if a string input is only a word
	private final static boolean isOneWord(String input) {
		if (input.contains(REGEX_WHITESPACE)) {
			return false;
		}
		else { 
			return true;
		}
	}

	public static ArrayList<String> retrieveInputForUpdate(String string) {
		ArrayList<String> output = new ArrayList<String>();
		String content[] = string.split(REGEX_WHITESPACE, 2);
		System.out.println(content.length);
		output.add(content[0]);
		if (content.length==1){
			output.add("");
		}
		else{
			output.add(content[1]);
		}
		return output;
	}
	
	
```
###### src\main\java\parser\RecurringTask.java
``` java
 */

package main.java.parser;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;

import main.java.logic.History;
import main.java.resources.Task;

public class RecurringTask {
	
	private static final String REGEX_WHITESPACE = " ";
	private static final String KEYWORD_FOR = " for ";
	private static final int LENGTH_OF_FOR = KEYWORD_FOR.length();
	private static final String KEYWORD_TIMES = " times";

	public final static ArrayList<Task> create(ArrayList<String> listFromLogic) {
		History history = History.getInstance();
		ArrayList<Task> recurringTasks = new ArrayList<Task>();
		int recurID = history.getNextRecurID();
		
		//input must contain keywords for and times
		if (listFromLogic.get(1).contains(KEYWORD_FOR) && listFromLogic.get(1).contains(KEYWORD_TIMES)) {
			String content[] = listFromLogic.get(1).split(REGEX_WHITESPACE, 2);
			int firstIndexToSplit = content[1].lastIndexOf(KEYWORD_FOR);
			int secondIndexToSplit = content[1].lastIndexOf(KEYWORD_TIMES);
			
			String recurringType = content[0];
			String taskContent = content[1].substring(0, firstIndexToSplit);
			int recurTimes = Integer.parseInt(content[1].substring(firstIndexToSplit + (LENGTH_OF_FOR), secondIndexToSplit));
			
			ArrayList<String> temp = new ArrayList<String>();
			temp.add(recurringType);
			temp.add(taskContent);
			Task task = new Task();
			
			switch(Parser.identifyTaskType(temp)) {
				case "deadline":
					task = CreateTask.createDeadline(Parser.identifyTaskType(temp), taskContent); 
					break;
				case "event":
					task = CreateTask.createEvent(Parser.identifyTaskType(temp), taskContent);
					break;
				default:
					task = new Task();
					break;
			}
			
			String taskDescription = task.getTaskDescription();
			String taskType = task.getTaskType();
			String recurringStartDate;
			String recurringEndDate;
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
			LocalDate recurEndDate;
			LocalDate recurStartDate;
			System.out.println(taskType);
			if(taskType.equals("deadline")) {
				String startTime = task.getStartTime();
				String endTime = task.getEndTime();
				String startDate = task.getStartDate();
				switch(recurringType){
					case "daily":
						recurringEndDate = task.getEndDate();
						recurEndDate = LocalDate.parse(recurringEndDate, formatter);

						for(int i=0; i<recurTimes; i++) {
							recurringTasks.add(new Task("deadline", taskDescription, startDate, recurringEndDate, startTime, endTime, false, true, recurID ));
							recurEndDate = recurEndDate.plusDays(1);
							recurringEndDate = recurEndDate.format(formatter);
						}
						break;
					case "weekly":
						recurringEndDate = task.getEndDate();
						recurEndDate = LocalDate.parse(recurringEndDate, formatter);

						for(int i=0; i<recurTimes; i++) {
							recurringTasks.add(new Task("deadline", taskDescription, startDate, recurringEndDate, startTime, endTime, false, true , recurID));
							recurEndDate = recurEndDate.plusWeeks(1);
							recurringEndDate = recurEndDate.format(formatter);
						}
						break;
					case "monthly":
						recurringEndDate = task.getEndDate();
						recurEndDate = LocalDate.parse(recurringEndDate, formatter);

						for(int i=0; i<recurTimes; i++) {
							recurringTasks.add(new Task("deadline", taskDescription, startDate, recurringEndDate, startTime, endTime, false, true , recurID));
							recurEndDate = recurEndDate.plusMonths(1);
							recurringEndDate = recurEndDate.format(formatter);
						}
						break;
					case "yearly":
						recurringEndDate = task.getEndDate();
						recurEndDate = LocalDate.parse(recurringEndDate, formatter);

						for(int i=0; i<recurTimes; i++) {
							recurringTasks.add(new Task("deadline", taskDescription, startDate, recurringEndDate, startTime, endTime, false, true , recurID ));
							recurEndDate = recurEndDate.plusYears(1);
							recurringEndDate = recurEndDate.format(formatter);
						}
						break;
					default:
						break;
					}
			}
			//task is event type
			else if(taskType.equals("event")) {
				String startTime = task.getStartTime();
				String endTime = task.getEndTime();
				switch(recurringType){
					case "daily":
						recurringStartDate = task.getStartDate();
						recurringEndDate = task.getEndDate();
						recurStartDate = LocalDate.parse(recurringStartDate, formatter);
						recurEndDate = LocalDate.parse(recurringEndDate, formatter);
						
						for(int i=0; i<recurTimes; i++) {
							recurringTasks.add(new Task("event", taskDescription, recurringStartDate, recurringEndDate, startTime, endTime, false, true , recurID));
							recurStartDate = recurStartDate.plusDays(1);
							recurEndDate = recurEndDate.plusDays(1);
							recurringStartDate = recurStartDate.format(formatter);
							recurringEndDate = recurEndDate.format(formatter);
						}
						break;
					case "weekly":
						recurringStartDate = task.getStartDate();
						recurringEndDate = task.getEndDate();
						recurStartDate = LocalDate.parse(recurringStartDate, formatter);
						recurEndDate = LocalDate.parse(recurringEndDate, formatter);
						
						for(int i=0; i<recurTimes; i++) {
							recurringTasks.add(new Task("event", taskDescription, recurringStartDate, recurringEndDate, startTime, endTime, false, true , recurID));
							recurStartDate = recurStartDate.plusWeeks(1);
							recurEndDate = recurEndDate.plusWeeks(1);
							recurringStartDate = recurStartDate.format(formatter);
							recurringEndDate = recurEndDate.format(formatter);
						}
						break;
					case "monthly":
						recurringStartDate = task.getStartDate();
						recurringEndDate = task.getEndDate();
						recurStartDate = LocalDate.parse(recurringStartDate, formatter);
						recurEndDate = LocalDate.parse(recurringEndDate, formatter);
						
						for(int i=0; i<recurTimes; i++) {
							recurringTasks.add(new Task("event", taskDescription, recurringStartDate, recurringEndDate, startTime, endTime, false, true , recurID));
							recurStartDate = recurStartDate.plusMonths(1);
							recurEndDate = recurEndDate.plusMonths(1);
							recurringStartDate = recurStartDate.format(formatter);
							recurringEndDate = recurEndDate.format(formatter);
						}
						break;
					case "yearly":
						recurringStartDate = task.getStartDate();
						recurringEndDate = task.getEndDate();
						recurStartDate = LocalDate.parse(recurringStartDate, formatter);
						recurEndDate = LocalDate.parse(recurringEndDate, formatter);
						
						for(int i=0; i<recurTimes; i++) {
							recurringTasks.add(new Task("event", taskDescription, recurringStartDate, recurringEndDate, startTime, endTime, false, true , recurID));
							recurStartDate = recurStartDate.plusYears(1);
							recurEndDate = recurEndDate.plusYears(1);
							recurringStartDate = recurStartDate.format(formatter);
							recurringEndDate = recurEndDate.format(formatter);
						}
						break;
					default :
						break;
				}
			}
			else 
				return recurringTasks;
		}
		return recurringTasks;
	}
}
```
###### src\main\java\resources\Task.java
``` java
 */

package main.java.resources;

public class Task {
	
	private String taskType;
	private String taskDescription;
	private String startDate;
	private String endDate;
	private String startTime;
	private String endTime;
	private boolean isCompleted;
	private boolean validDTF;
	private int recurringID;
	
	/********************** Constructor ************************/
	//creates an empty task
	public Task() {
		
		setTaskType("-");
		setTaskDescription("-");
		setStartDate("-");
		setEndDate("-");
		setStartTime("-");
		setEndTime("-");
		setCompleted(false);
		setValidDT(false);
		setRecurringID(0);
	}
	
	public Task (String newTaskType, String newTaskDescription, String newStartDate, String newEndDate,
									String newStartTime, String newEndTime, boolean taskStatus,
									boolean dateTimeFormat, int newRecurringID) {
			
		setTaskType(newTaskType);
		setTaskDescription(newTaskDescription);
		setStartDate(newStartDate);
		setEndDate(newEndDate);
		setStartTime(newStartTime);
		setEndTime(newEndTime);
		setCompleted(taskStatus);
		setValidDT(dateTimeFormat);
		setRecurringID(newRecurringID);
	}

	/********************* Accessors *************************/
	public String getTaskType() {
		return taskType;
	}
	
	public String getTaskDescription() {
		return taskDescription;
	}
	
	public String getStartDate() {
		return startDate;
	}
	
	public String getEndDate() {
		return endDate;
	}
	
	public String getStartTime() {
		return startTime;
	}
	
	public String getEndTime() {
		return endTime;
	}
	
	public boolean getIsCompleted() {
		return isCompleted;
	}
	
	public boolean getIsDateTimeValid() {
		return validDTF;
	}
	
	public int getRecurringID() {
		return recurringID;
	}
	/*********************** Mutators ************************/
	public void setTaskType(String newTaskType) {
		this.taskType = newTaskType;
	}
	
	public void setTaskDescription(String newTaskDescription) {
		this.taskDescription = newTaskDescription;
	}
	
	public void setStartDate(String newStartDate) {
		this.startDate = newStartDate;
	}
	
	public void setEndDate(String newEndDate) {
		this.endDate = newEndDate;
	}
	
	public void setStartTime(String newStartTime) {
		this.startTime = newStartTime;
	}
	
	public void setEndTime(String newEndTime) {
		this.endTime = newEndTime;
	}
	
	public void setCompleted(boolean newTaskStatus) {
		this.isCompleted = newTaskStatus;
	}
	
	public void setValidDT(boolean newDTF) {
		this.validDTF = newDTF;
	}
	
	public void setRecurringID(int newRecurringID) {
		this.recurringID = newRecurringID;
	}
	
	//Overriding equals() method
	@Override
	public boolean equals(Object obj) {
		boolean result = false;
		if (obj instanceof Task) {
			Task task = (Task) obj;
			return this.getTaskType().equals(task.getTaskType()) && 
					this.getTaskDescription().equals(task.getTaskDescription()) &&
						this.getStartDate().equals(task.getStartDate()) &&
							this.getEndDate().equals(task.getEndDate()) &&
								this.getStartTime().equals(task.getStartTime()) && 
									this.getEndTime().equals(task.getEndTime()) &&
										this.getIsCompleted() == task.getIsCompleted() &&
											this.getIsDateTimeValid() == task.getIsDateTimeValid() && 
												this.getRecurringID() == task.getRecurringID();
		}
	return result;
	}
}
```
###### src\main\resources\layouts\Search.fxml
``` fxml

<?import java.lang.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.text.*?>

<AnchorPane prefHeight="605.0" prefWidth="900.0" xmlns:fx="http://javafx.com/fxml/1" xmlns="http://javafx.com/javafx/2.2" fx:controller="main.java.gui.SearchController">
  <!-- TODO Add Nodes -->
  <children>
    <Label prefHeight="35.0" style="-fx-background-color: rgba(160, 082, 045);" text="  Search Results" textFill="WHITE" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="150.0" AnchorPane.topAnchor="0.0">
      <font>
        <Font size="25.0" fx:id="x1" />
      </font>
    </Label>
    <ListView fx:id="searchList" prefHeight="200.0" prefWidth="200.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="35.0" />
    <Label fx:id="clock" font="$x1" prefHeight="35.0" prefWidth="150.0" style="-fx-background-color: rgba(000, 000, 000);" text="" textFill="#66ffed" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" />
  </children>
</AnchorPane>
```
